=============================================================
WORKSPACE FOLDER: my-homepage
=============================================================

--- File: my-homepage\.gitignore ---
frontend/config.js
frontend/bookmarks.js
backend/.env
backend/node_modules/


--- File: my-homepage\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: my-homepage\.github\workflows\container-app-build.yml ---
# Test 6
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
    secrets: inherit

--- File: my-homepage\.github\workflows\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ inputs.commit_sha }}
    secrets: inherit

--- File: my-homepage\.github\workflows\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: my-homepage\.github\workflows\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: my-homepage\.github\workflows\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

--- File: my-homepage\backend\.env ---
AZURE_APP_CONFIG_ENDPOINT=https://infra-appconfig.azconfig.io
APP_CONFIG_PREFIX=homepage
AZURE_TENANT_ID="2236b5e4-81d2-4d82-bde5-17b1037999ea"


--- File: my-homepage\backend\package.json ---
{
  "name": "my-homepage-api",
  "version": "1.0.0",
  "type": "module",
  "description": "My Homepage Backend API with Azure Cosmos DB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "license": "MIT",
  "dependencies": {
    "@azure/app-configuration": "^1.11.0",
    "@azure/cosmos": "^4.0.0",
    "@azure/identity": "^4.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2",
    "express-oauth2-jwt-bearer": "^1.7.4",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}


--- File: my-homepage\backend\server.js ---
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import cors from 'cors';
import { CosmosClient } from '@azure/cosmos';
import { DefaultAzureCredential } from '@azure/identity';
import { createRequireAuth } from './middleware/auth.js';
import { fetchAppConfig } from './startup/appConfig.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware that does NOT depend on async config — safe to register now
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

async function startServer() {
  // Step 1: Fetch AUTH0_DOMAIN and AUTH0_AUDIENCE from Azure App Configuration.
  const { auth0Domain, auth0Audience, cosmosDbEndpoint } = await fetchAppConfig();

  // Step 2: Build the Auth0 JWT middleware now that we have the values.
  const requireAuth = createRequireAuth({ auth0Domain, auth0Audience });

  // Step 3: Initialize Cosmos DB client.
  const DATABASE_NAME = process.env.COSMOS_DB_DATABASE_NAME || 'HomepageDB';
  const CONTAINER_NAME = process.env.COSMOS_DB_CONTAINER_NAME || 'userdata';

  let container;
  try {
    const credential = new DefaultAzureCredential();
    const client = new CosmosClient({
      endpoint: cosmosDbEndpoint,
      aadCredentials: credential
    });

    const database = client.database(DATABASE_NAME);
    container = database.container(CONTAINER_NAME);
    console.log('Connected to Cosmos DB using Azure Identity');
  } catch (error) {
    console.error('Failed to connect to Cosmos DB:', error);
    process.exit(1);
  }

  // Step 4: Register all routes.

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: DATABASE_NAME,
      container: CONTAINER_NAME
    });
  });

  // Database initialization endpoint
  app.post('/api/admin/init-database', requireAuth, async (req, res) => {
    try {
      const credential = new DefaultAzureCredential();
      const client = new CosmosClient({
        endpoint: cosmosDbEndpoint,
        aadCredentials: credential
      });

      // Create database if it doesn't exist
      const { database } = await client.databases.createIfNotExists({
        id: DATABASE_NAME
      });

      // Create container if it doesn't exist
      const { container: newContainer } = await database.containers.createIfNotExists({
        id: CONTAINER_NAME,
        partitionKey: {
          paths: ['/userId']
        }
      });

      // Optionally seed bookmarks for the current user
      const userId = req.auth.payload.sub;
      let seeded = false;

      if (req.body.bookmarks) {
        const bookmarksDoc = {
          id: `bookmarks_${userId}`,
          userId,
          type: 'bookmarks',
          bookmarks: req.body.bookmarks,
          updatedAt: new Date().toISOString()
        };
        await newContainer.items.upsert(bookmarksDoc);
        seeded = true;
      }

      res.json({
        success: true,
        message: 'Database initialized successfully',
        database: DATABASE_NAME,
        container: CONTAINER_NAME,
        seeded
      });
    } catch (error) {
      console.error('Error initializing database:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize database',
        message: error.message
      });
    }
  });

  // Get bookmarks for the authenticated user
  app.get('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;

      const querySpec = {
        query: 'SELECT * FROM c WHERE c.type = @type AND c.userId = @userId',
        parameters: [
          { name: '@type', value: 'bookmarks' },
          { name: '@userId', value: userId }
        ]
      };

      const { resources } = await container.items.query(querySpec).fetchAll();

      if (resources.length === 0) {
        return res.json({ bookmarks: [] });
      }

      res.json({ bookmarks: resources[0].bookmarks });
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ error: 'Failed to fetch bookmarks', message: error.message });
    }
  });

  // Save/update bookmarks for the authenticated user
  app.put('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;
      const { bookmarks } = req.body;

      if (!Array.isArray(bookmarks)) {
        return res.status(400).json({ error: 'Request body must contain a bookmarks array' });
      }

      const bookmarksDoc = {
        id: `bookmarks_${userId}`,
        userId,
        type: 'bookmarks',
        bookmarks,
        updatedAt: new Date().toISOString()
      };

      const { resource } = await container.items.upsert(bookmarksDoc);

      res.json({ bookmarks: resource.bookmarks, updatedAt: resource.updatedAt });
    } catch (error) {
      console.error('Error saving bookmarks:', error);
      res.status(500).json({ error: 'Failed to save bookmarks', message: error.message });
    }
  });

  // In production, serve frontend static files
  if (process.env.NODE_ENV === 'production') {
    app.use(express.static('../frontend'));
  }

  // 404 handler
  app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
  });

  // Error handler
  app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error', message: err.message });
  });

  // Step 5: Start listening only after all setup is complete.
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`Database: ${DATABASE_NAME}`);
    console.log(`Container: ${CONTAINER_NAME}`);
    console.log(`Auth0 domain: ${auth0Domain}`);
    console.log(`Health check: http://localhost:${PORT}/health`);
  });
}

startServer().catch((error) => {
  console.error('Fatal startup error:', error);
  process.exit(1);
});

export default app;


--- File: my-homepage\backend\middleware\auth.js ---
import { auth } from 'express-oauth2-jwt-bearer';

/**
 * Creates the Auth0 JWT validation middleware.
 *
 * Must be called after Azure App Configuration values are fetched,
 * because auth() is a synchronous factory that reads its arguments immediately.
 *
 * @param {{ auth0Domain: string, auth0Audience: string }} config
 * @returns {import('express').RequestHandler}
 */
export function createRequireAuth({ auth0Domain, auth0Audience }) {
  return auth({
    audience: auth0Audience,
    issuerBaseURL: `https://${auth0Domain}/`,
    tokenSigningAlg: 'RS256',
  });
}


--- File: my-homepage\backend\startup\appConfig.js ---
import { AppConfigurationClient } from '@azure/app-configuration';
import { DefaultAzureCredential } from '@azure/identity';

/**
 * Fetches application configuration from Azure App Configuration.
 *
 * AZURE_APP_CONFIG_ENDPOINT is infrastructure config (not a secret) and
 * is injected as a plain environment variable on the Container App.
 *
 * @returns {Promise<{ auth0Domain: string, auth0Audience: string, cosmosDbEndpoint: string }>}
 */
export async function fetchAppConfig() {
  const endpoint = process.env.AZURE_APP_CONFIG_ENDPOINT;

  if (!endpoint) {
    throw new Error(
      'AZURE_APP_CONFIG_ENDPOINT environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const prefix = process.env.APP_CONFIG_PREFIX;

  if (!prefix) {
    throw new Error(
      'APP_CONFIG_PREFIX environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const credential = new DefaultAzureCredential();
  const client = new AppConfigurationClient(endpoint, credential);

  const [domainSetting, audienceSetting, cosmosEndpointSetting] = await Promise.all([
    client.getConfigurationSetting({ key: 'AUTH0_DOMAIN' }),
    client.getConfigurationSetting({ key: `${prefix}/AUTH0_AUDIENCE` }),
    client.getConfigurationSetting({ key: 'cosmos_db_endpoint' }),
  ]);

  const auth0Domain = domainSetting.value;
  const auth0Audience = audienceSetting.value;
  const cosmosDbEndpoint = cosmosEndpointSetting.value;

  if (!auth0Domain || !auth0Audience || !cosmosDbEndpoint) {
    throw new Error(
      `Azure App Configuration is missing required keys. ` +
      `Ensure AUTH0_DOMAIN, ${prefix}/AUTH0_AUDIENCE, and cosmos_db_endpoint are set in the store.`
    );
  }

  console.log('[appConfig] Application config fetched from Azure App Configuration');
  return { auth0Domain, auth0Audience, cosmosDbEndpoint };
}


--- File: my-homepage\frontend\auth.js ---
/* global auth0, CONFIG */

let auth0Client = null;

async function initAuth() {
  auth0Client = await auth0.createAuth0Client({
    domain: CONFIG.auth0Domain,
    clientId: CONFIG.auth0ClientId,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: CONFIG.auth0Audience,
    },
  });

  // Handle redirect callback
  const query = window.location.search;
  if (query.includes("code=") && query.includes("state=")) {
    await auth0Client.handleRedirectCallback();
    window.history.replaceState({}, document.title, window.location.pathname);
  }

  return auth0Client;
}

async function login() {
  await auth0Client.loginWithRedirect();
}

async function logout() {
  await auth0Client.logout({
    logoutParams: { returnTo: window.location.origin },
  });
}

async function getToken() {
  return auth0Client.getTokenSilently({
    authorizationParams: { audience: CONFIG.auth0Audience },
  });
}

async function isAuthenticated() {
  return auth0Client.isAuthenticated();
}

async function getUser() {
  return auth0Client.getUser();
}


--- File: my-homepage\frontend\bookmarks.js ---
const bookmarks = [
  {
    name: "Home",
    children: [
      {
        name: "Voice",
        url: "http://voice.google.com/u/0/messages"
      },
      {
        name: "Chess",
        url: "https://www.chess.com/"
      },
      {
        name: "Reddit",
        url: "https://www.reddit.com/"
      },
      {
        name: "YouTube",
        url: "https://www.youtube.com/"
      },
      {
        name: "Google",
        url: "http://google.com/"
      },
      {
        name: "Workout",
        url: "https://docs.google.com/spreadsheets/d/1qdizKHXq5e465dt5ChbcKsGTYG6QmjON/edit?gid=1734961154#gid=1734961154"
      },
      {
        name: "Google Calendar",
        url: "https://calendar.google.com/calendar/u/0/r"
      },
      {
        name: "Amazon",
        url: "https://www.amazon.com/"
      },
      {
        name: "Nelsonhub",
        url: "http://192.168.50.131/"
      }
    ]
  },
  {
    name: "Projects",
    children: [
      {
        name: "Spacelift",
        url: "https://nelsong6.app.spacelift.io/stack/new-pokemon-appeared/run/01K4JKE4EGWVCRKAB6BZ6RXHJB"
      },
      {
        name: "Azure",
        url: "https://portal.azure.com/#home"
      },
      {
        name: "New Pokemon Appears",
        url: "https://github.com/nelsong6/new-pokemon-appeared/milestone/4"
      }
    ]
  },
  {
    name: "Bills",
    children: [
      {
        name: "Ameriprise",
        url: "https://www.ameriprise.com/client-login"
      },
      {
        name: "Chase",
        url: "https://www.chase.com/"
      },
      {
        name: "Loancare",
        url: "https://myloancare.com/web/home"
      },
      {
        name: "Water Delivery",
        url: "https://drink.water.com/"
      },
      {
        name: "Haircut",
        url: "https://www.vagaro.com/roots66salons"
      }
    ]
  },
  {
    name: "Dev",
    children: [
      {
        name: "Auth0",
        url: "http://auth0.com/"
      },
      {
        name: "Github",
        url: "https://github.com/nelsong6"
      },
      {
        name: "Spacelift",
        url: "https://nelsong6.app.us.spacelift.io/dashboard"
      },
      {
        name: "Claude",
        url: "https://platform.claude.com/"
      }
    ]
  }
];

--- File: my-homepage\frontend\bookmarks.js.example ---
const bookmarks = [
  {
    name: "Social",
    children: [
      { name: "Twitter", url: "https://twitter.com" },
      { name: "Reddit", url: "https://reddit.com" },
      { name: "YouTube", url: "https://youtube.com" },
    ],
  },
  {
    name: "Dev",
    url: "https://github.com",
    children: [
      { name: "GitHub", url: "https://github.com" },
      { name: "Stack Overflow", url: "https://stackoverflow.com" },
      { name: "MDN Web Docs", url: "https://developer.mozilla.org" },
    ],
  },
  {
    name: "News",
    children: [
      { name: "Hacker News", url: "https://news.ycombinator.com" },
      { name: "Lobsters", url: "https://lobste.rs" },
    ],
  },
  {
    name: "Tools",
    children: [
      {
        name: "Search",
        children: [
          { name: "Google", url: "https://google.com" },
          { name: "DuckDuckGo", url: "https://duckduckgo.com" },
        ],
      },
      { name: "Email", url: "https://mail.google.com" },
    ],
  },
];


--- File: my-homepage\frontend\config.js.example ---
const CONFIG = {
  auth0Domain: "<AUTH0_DOMAIN>",
  auth0ClientId: "<AUTH0_CLIENT_ID>",
  auth0Audience: "<AUTH0_AUDIENCE>",
  apiUrl: "http://localhost:3000",
};


--- File: my-homepage\frontend\generate-config.sh ---
#!/bin/bash
# Generates frontend/config.js from environment variables.
#
# Usage (local dev):
#   source backend/.env     # or export the vars manually
#   export AUTH0_DOMAIN="dev-gtdi5x5p0nmticqd.us.auth0.com"
#   export AUTH0_CLIENT_ID="<your-client-id>"
#   export AUTH0_AUDIENCE="https://homepage.api.yourdomain.com"
#   export API_URL="https://homepage.api.yourdomain.com"
#   bash frontend/generate-config.sh
#
# In the CI/CD pipeline, these variables should be set from Terraform outputs
# or Azure App Configuration before this script runs.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

: "${AUTH0_DOMAIN:?ERROR: AUTH0_DOMAIN is not set}"
: "${AUTH0_CLIENT_ID:?ERROR: AUTH0_CLIENT_ID is not set}"
: "${AUTH0_AUDIENCE:?ERROR: AUTH0_AUDIENCE is not set}"
: "${API_URL:?ERROR: API_URL is not set}"

cat <<EOF > "$SCRIPT_DIR/config.js"
const CONFIG = {
  auth0Domain: "${AUTH0_DOMAIN}",
  auth0ClientId: "${AUTH0_CLIENT_ID}",
  auth0Audience: "${AUTH0_AUDIENCE}",
  apiUrl: "${API_URL}",
};
EOF

echo "Successfully generated $SCRIPT_DIR/config.js"


--- File: my-homepage\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Login screen -->
  <div id="login-screen">
    <div class="login-box">
      <h1>Home</h1>
      <button id="login-btn">Log In</button>
    </div>
  </div>

  <!-- Loading state -->
  <div id="loading" class="hidden">Loading…</div>

  <!-- Main app (hidden until authenticated) -->
  <div id="app" class="hidden">
    <div id="toolbar">
      <button id="expand-all">Expand All</button>
      <button id="collapse-all">Collapse All</button>
      <div id="user-info">
        <span id="user-email"></span>
        <button id="logout-btn">Log Out</button>
      </div>
    </div>
    <div id="tree"></div>
  </div>

  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
  <script src="config.js"></script>
  <script src="auth.js"></script>
  <script src="script.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js");
    }
  </script>
</body>
</html>


--- File: my-homepage\frontend\script.js ---
/* global CONFIG, initAuth, login, logout, getToken, isAuthenticated, getUser */

// ── DOM references ──────────────────────────────────────────────
const loginScreen = document.getElementById("login-screen");
const loadingEl = document.getElementById("loading");
const appEl = document.getElementById("app");
const tree = document.getElementById("tree");

const CACHE_KEY = "cached_bookmarks";

// ── App entry point ─────────────────────────────────────────────

(async function main() {
  const cached = loadCachedBookmarks();

  // If we have cached data, paint immediately — no waiting for Auth0.
  if (cached) {
    loginScreen.classList.add("hidden");
    loadingEl.classList.add("hidden");
    appEl.classList.remove("hidden");
    renderBookmarks(cached);
  } else {
    // No cache — show loading while Auth0 initializes
    loginScreen.classList.add("hidden");
    loadingEl.classList.remove("hidden");
  }

  // Auth0 init happens in the background while cached UI is already visible.
  await initAuth();

  if (await isAuthenticated()) {
    await showApp(cached);
  } else if (cached) {
    // Had stale cache but session expired — fall back to login
    showLogin();
  } else {
    showLogin();
  }
})();

// ── Auth flows ──────────────────────────────────────────────────

function showLogin() {
  loadingEl.classList.add("hidden");
  appEl.classList.add("hidden");
  loginScreen.classList.remove("hidden");
}

async function showApp(alreadyRenderedCache) {
  loadingEl.classList.add("hidden");
  loginScreen.classList.add("hidden");
  appEl.classList.remove("hidden");

  // Show user email
  const user = await getUser();
  document.getElementById("user-email").textContent = user.email || user.name || "";

  // Fetch fresh bookmarks from API (background revalidation)
  const fresh = await fetchBookmarks();

  // Only re-render if the data actually changed (or if we had no cache)
  if (!alreadyRenderedCache || !bookmarksEqual(alreadyRenderedCache, fresh)) {
    saveCachedBookmarks(fresh);
    renderBookmarks(fresh);
  }
}

// ── localStorage helpers ────────────────────────────────────────

function loadCachedBookmarks() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

function saveCachedBookmarks(bookmarks) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(bookmarks));
  } catch {
    // Storage full or unavailable — non-critical
  }
}

function bookmarksEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

// ── API ─────────────────────────────────────────────────────────

async function fetchBookmarks() {
  try {
    const token = await getToken();
    const res = await fetch(`${CONFIG.apiUrl}/api/bookmarks`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error(`API error: ${res.status}`);

    const data = await res.json();
    return data.bookmarks || [];
  } catch (err) {
    console.error("Failed to fetch bookmarks:", err);
    // On network failure, return whatever we have cached
    return loadCachedBookmarks() || [];
  }
}

// ── Rendering ───────────────────────────────────────────────────

function renderBookmarks(bookmarks) {
  tree.innerHTML = "";

  if (bookmarks.length === 0) {
    tree.textContent = "No bookmarks yet.";
    return;
  }

  tree.style.setProperty(
    "--url-left",
    Math.ceil(calcMaxRowWidth(bookmarks, "")) + 2 + "ch"
  );
  tree.appendChild(renderList(bookmarks, ""));
}

// Calculate the max visual width of all tree rows (in ch units) so
// hover-revealed URLs can be aligned in a single consistent column.
function calcMaxRowWidth(items, prefix) {
  let max = 0;
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;
    // prefix+connector chars + toggle/spacer (1ch + 0.6ch gap) + name + arrow if link
    const width = (prefix + connector).length + 1.6 + item.name.length + (item.url ? 1.15 : 0);
    if (width > max) max = width;
    if (hasChildren) {
      const childMax = calcMaxRowWidth(item.children, childPrefix);
      if (childMax > max) max = childMax;
    }
  });
  return max;
}

// Build DOM for a list of sibling nodes.
// `prefix` is the inherited string of "│   " / "    " segments from ancestors.
function renderList(items, prefix) {
  const frag = document.createDocumentFragment();
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;

    // Row
    const row = document.createElement("div");
    row.className = "node";

    // Prefix (inherited tree lines)
    const pre = document.createElement("span");
    pre.className = "node-prefix";
    pre.textContent = prefix + connector;
    row.appendChild(pre);

    // Toggle button or spacer
    if (hasChildren) {
      const btn = document.createElement("button");
      btn.className = "node-toggle";
      btn.textContent = ">";
      btn.setAttribute("aria-label", "expand");
      row.appendChild(btn);
    } else {
      const spacer = document.createElement("span");
      spacer.className = "node-spacer";
      row.appendChild(spacer);
    }

    // Label
    const label = document.createElement("span");
    label.className = "node-label" + (hasChildren ? " folder" : "");
    if (item.url) {
      const a = document.createElement("a");
      a.href = item.url;
      a.textContent = item.name;
      label.appendChild(a);
      const arrow = document.createElement("span");
      arrow.className = "link-indicator";
      arrow.textContent = "↗";
      arrow.setAttribute("aria-hidden", "true");
      label.appendChild(arrow);
    } else {
      label.textContent = item.name;
    }
    row.appendChild(label);

    // URL hint shown on hover
    if (item.url) {
      const urlSpan = document.createElement("span");
      urlSpan.className = "node-url";
      urlSpan.textContent = item.url;
      row.appendChild(urlSpan);
    }

    frag.appendChild(row);

    // Children
    if (hasChildren) {
      const childrenContainer = document.createElement("div");
      childrenContainer.className = "children";
      childrenContainer.appendChild(renderList(item.children, childPrefix));
      frag.appendChild(childrenContainer);

      // Wire toggle — whole row triggers expand/collapse
      const btn = row.querySelector(".node-toggle");
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        // If click landed on a link, let it navigate instead of toggling
        if (e.target.closest("a")) return;
        const open = childrenContainer.classList.toggle("open");
        btn.classList.toggle("open", open);
        btn.textContent = open ? "v" : ">";
        btn.setAttribute("aria-label", open ? "collapse" : "expand");
      });
    } else if (item.url) {
      // Wire link — whole row navigates
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        if (e.target.tagName === "A") return; // let native <a> handle itself
        window.location.href = item.url;
      });
    }
  });
  return frag;
}

// ── Toolbar ─────────────────────────────────────────────────────

document.getElementById("expand-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.add("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.add("open");
    btn.textContent = "v";
    btn.setAttribute("aria-label", "collapse");
  });
});

document.getElementById("collapse-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.remove("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.remove("open");
    btn.textContent = ">";
    btn.setAttribute("aria-label", "expand");
  });
});

document.getElementById("login-btn").addEventListener("click", login);
document.getElementById("logout-btn").addEventListener("click", logout);


--- File: my-homepage\frontend\style.css ---
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #1e1e2e;
  color: #cdd6f4;
  font-family: "Cascadia Code", "Fira Code", "JetBrains Mono", "Consolas", monospace;
  font-size: 18px;
  padding: 32px;
  line-height: 1.6;
}

#toolbar {
  max-width: 720px;
  margin-bottom: 12px;
  display: flex;
  gap: 8px;
}

#toolbar button {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#toolbar button:hover {
  background: #45475a;
}

#tree {
  max-width: 720px;
}

/* ── Each node row ─────────────────────────────── */

.node {
  display: flex;
  align-items: baseline;
  position: relative;
}

.node.clickable {
  cursor: pointer;
}

.node.clickable:hover {
  background: #2a2a3e;
}

.node-prefix {
  white-space: pre;
  color: #585b70;
  user-select: none;
}

.node-toggle {
  background: none;
  border: none;
  color: #585b70;
  cursor: pointer;
  font-family: inherit;
  font-size: inherit;
  padding: 0;
  width: 1ch;
  margin-right: 0.6ch;
  text-align: center;
  user-select: none;
  transition: color 0.15s;
}

.node-toggle:hover {
  color: #cdd6f4;
}

.node-toggle.open {
  /* purely cosmetic class — JS swaps the character */
}

.node-spacer {
  width: 1ch;
  margin-right: 0.6ch;
  display: inline-block;
}

.node-label a {
  color: #89b4fa;
  text-decoration: none;
  transition: color 0.15s;
}

.node-label a:hover {
  color: #b4befe;
  text-decoration: underline;
}

.link-indicator {
  color: #585b70;
  font-size: 0.75em;
  margin-left: 0.4ch;
  transition: color 0.15s;
}

.node.clickable:hover .link-indicator,
.node-label a:hover + .link-indicator {
  color: #b4befe;
}

.node-label.folder {
  color: #a6e3a1;
  font-weight: bold;
}

.node-label.folder a {
  color: #a6e3a1;
}

.node-label.folder a:hover {
  color: #b4befe;
}

/* ── Hover URL hint ───────────────────────────── */

.node-url {
  display: none;
  position: absolute;
  left: var(--url-left);
  color: #585b70;
  pointer-events: none;
  white-space: nowrap;
}

.node:hover > .node-url {
  display: inline;
}

/* ── Children container ────────────────────────── */

.children {
  display: none;
}

.children.open {
  display: block;
}

/* ── Hidden utility ──────────────────────────── */

.hidden {
  display: none !important;
}

/* ── Loading state ───────────────────────────── */

#loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
  color: #585b70;
  font-size: 1.2em;
}

/* ── Login screen ────────────────────────────── */

#login-screen {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
}

.login-box {
  text-align: center;
}

.login-box h1 {
  color: #cdd6f4;
  font-size: 2em;
  margin-bottom: 24px;
}

#login-btn {
  background: #89b4fa;
  color: #1e1e2e;
  border: none;
  border-radius: 4px;
  padding: 10px 32px;
  font-family: inherit;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.15s;
}

#login-btn:hover {
  background: #b4befe;
}

/* ── User info / logout ──────────────────────── */

#user-info {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

#user-email {
  color: #585b70;
  font-size: 0.8em;
}

#logout-btn {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#logout-btn:hover {
  background: #45475a;
}

/* ── Mobile responsive ───────────────────────── */

@media (max-width: 600px) {
  body {
    padding: 12px;
    font-size: 15px;
  }

  #toolbar {
    flex-wrap: wrap;
  }

  #user-info {
    width: 100%;
    margin-left: 0;
    justify-content: flex-end;
  }

  #tree {
    max-width: 100%;
    overflow-x: auto;
  }

  .node-url {
    display: none !important;
  }
}


--- File: my-homepage\frontend\sw.js ---
const CACHE_NAME = "app-shell-v1";
const SHELL_ASSETS = [
  "/",
  "/index.html",
  "/style.css",
  "/script.js",
  "/auth.js",
  "/config.js",
];

// ── Install: pre-cache the app shell ────────────────────────────
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(SHELL_ASSETS))
  );
  self.skipWaiting();
});

// ── Activate: clean up old caches ───────────────────────────────
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys
          .filter((key) => key !== CACHE_NAME)
          .map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

// ── Fetch: cache-first for same-origin, network-only for API/CDN ─
self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);

  // Skip non-GET requests
  if (event.request.method !== "GET") return;

  // Skip API calls — let the app handle those with its own caching
  if (url.pathname.startsWith("/api/")) return;

  // Skip cross-origin requests (Auth0 CDN, etc.)
  if (url.origin !== self.location.origin) return;

  event.respondWith(
    caches.match(event.request).then(
      (cached) =>
        cached ||
        fetch(event.request).then((response) => {
          // Cache new same-origin assets on the fly
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
          return response;
        })
    )
  );
});


--- File: my-homepage\frontend\workspace_context.txt ---
=============================================================
WORKSPACE FOLDER: my-homepage
=============================================================

--- File: my-homepage\.gitignore ---
frontend/config.js
frontend/bookmarks.js
backend/.env
backend/node_modules/


--- File: my-homepage\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: my-homepage\.github\workflows\container-app-build.yml ---
# Test 6
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
    secrets: inherit

--- File: my-homepage\.github\workflows\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ inputs.commit_sha }}
    secrets: inherit

--- File: my-homepage\.github\workflows\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: my-homepage\.github\workflows\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: my-homepage\.github\workflows\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

--- File: my-homepage\backend\.env ---
AZURE_APP_CONFIG_ENDPOINT=https://infra-appconfig.azconfig.io
APP_CONFIG_PREFIX=homepage
AZURE_TENANT_ID="2236b5e4-81d2-4d82-bde5-17b1037999ea"


--- File: my-homepage\backend\package.json ---
{
  "name": "my-homepage-api",
  "version": "1.0.0",
  "type": "module",
  "description": "My Homepage Backend API with Azure Cosmos DB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "license": "MIT",
  "dependencies": {
    "@azure/app-configuration": "^1.11.0",
    "@azure/cosmos": "^4.0.0",
    "@azure/identity": "^4.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2",
    "express-oauth2-jwt-bearer": "^1.7.4",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}


--- File: my-homepage\backend\server.js ---
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import cors from 'cors';
import { CosmosClient } from '@azure/cosmos';
import { DefaultAzureCredential } from '@azure/identity';
import { createRequireAuth } from './middleware/auth.js';
import { fetchAppConfig } from './startup/appConfig.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware that does NOT depend on async config — safe to register now
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

async function startServer() {
  // Step 1: Fetch AUTH0_DOMAIN and AUTH0_AUDIENCE from Azure App Configuration.
  const { auth0Domain, auth0Audience, cosmosDbEndpoint } = await fetchAppConfig();

  // Step 2: Build the Auth0 JWT middleware now that we have the values.
  const requireAuth = createRequireAuth({ auth0Domain, auth0Audience });

  // Step 3: Initialize Cosmos DB client.
  const DATABASE_NAME = process.env.COSMOS_DB_DATABASE_NAME || 'HomepageDB';
  const CONTAINER_NAME = process.env.COSMOS_DB_CONTAINER_NAME || 'userdata';

  let container;
  try {
    const credential = new DefaultAzureCredential();
    const client = new CosmosClient({
      endpoint: cosmosDbEndpoint,
      aadCredentials: credential
    });

    const database = client.database(DATABASE_NAME);
    container = database.container(CONTAINER_NAME);
    console.log('Connected to Cosmos DB using Azure Identity');
  } catch (error) {
    console.error('Failed to connect to Cosmos DB:', error);
    process.exit(1);
  }

  // Step 4: Register all routes.

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: DATABASE_NAME,
      container: CONTAINER_NAME
    });
  });

  // Database initialization endpoint
  app.post('/api/admin/init-database', requireAuth, async (req, res) => {
    try {
      const credential = new DefaultAzureCredential();
      const client = new CosmosClient({
        endpoint: cosmosDbEndpoint,
        aadCredentials: credential
      });

      // Create database if it doesn't exist
      const { database } = await client.databases.createIfNotExists({
        id: DATABASE_NAME
      });

      // Create container if it doesn't exist
      const { container: newContainer } = await database.containers.createIfNotExists({
        id: CONTAINER_NAME,
        partitionKey: {
          paths: ['/userId']
        }
      });

      // Optionally seed bookmarks for the current user
      const userId = req.auth.payload.sub;
      let seeded = false;

      if (req.body.bookmarks) {
        const bookmarksDoc = {
          id: `bookmarks_${userId}`,
          userId,
          type: 'bookmarks',
          bookmarks: req.body.bookmarks,
          updatedAt: new Date().toISOString()
        };
        await newContainer.items.upsert(bookmarksDoc);
        seeded = true;
      }

      res.json({
        success: true,
        message: 'Database initialized successfully',
        database: DATABASE_NAME,
        container: CONTAINER_NAME,
        seeded
      });
    } catch (error) {
      console.error('Error initializing database:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize database',
        message: error.message
      });
    }
  });

  // Get bookmarks for the authenticated user
  app.get('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;

      const querySpec = {
        query: 'SELECT * FROM c WHERE c.type = @type AND c.userId = @userId',
        parameters: [
          { name: '@type', value: 'bookmarks' },
          { name: '@userId', value: userId }
        ]
      };

      const { resources } = await container.items.query(querySpec).fetchAll();

      if (resources.length === 0) {
        return res.json({ bookmarks: [] });
      }

      res.json({ bookmarks: resources[0].bookmarks });
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ error: 'Failed to fetch bookmarks', message: error.message });
    }
  });

  // Save/update bookmarks for the authenticated user
  app.put('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;
      const { bookmarks } = req.body;

      if (!Array.isArray(bookmarks)) {
        return res.status(400).json({ error: 'Request body must contain a bookmarks array' });
      }

      const bookmarksDoc = {
        id: `bookmarks_${userId}`,
        userId,
        type: 'bookmarks',
        bookmarks,
        updatedAt: new Date().toISOString()
      };

      const { resource } = await container.items.upsert(bookmarksDoc);

      res.json({ bookmarks: resource.bookmarks, updatedAt: resource.updatedAt });
    } catch (error) {
      console.error('Error saving bookmarks:', error);
      res.status(500).json({ error: 'Failed to save bookmarks', message: error.message });
    }
  });

  // In production, serve frontend static files
  if (process.env.NODE_ENV === 'production') {
    app.use(express.static('../frontend'));
  }

  // 404 handler
  app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
  });

  // Error handler
  app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error', message: err.message });
  });

  // Step 5: Start listening only after all setup is complete.
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`Database: ${DATABASE_NAME}`);
    console.log(`Container: ${CONTAINER_NAME}`);
    console.log(`Auth0 domain: ${auth0Domain}`);
    console.log(`Health check: http://localhost:${PORT}/health`);
  });
}

startServer().catch((error) => {
  console.error('Fatal startup error:', error);
  process.exit(1);
});

export default app;


--- File: my-homepage\backend\middleware\auth.js ---
import { auth } from 'express-oauth2-jwt-bearer';

/**
 * Creates the Auth0 JWT validation middleware.
 *
 * Must be called after Azure App Configuration values are fetched,
 * because auth() is a synchronous factory that reads its arguments immediately.
 *
 * @param {{ auth0Domain: string, auth0Audience: string }} config
 * @returns {import('express').RequestHandler}
 */
export function createRequireAuth({ auth0Domain, auth0Audience }) {
  return auth({
    audience: auth0Audience,
    issuerBaseURL: `https://${auth0Domain}/`,
    tokenSigningAlg: 'RS256',
  });
}


--- File: my-homepage\backend\startup\appConfig.js ---
import { AppConfigurationClient } from '@azure/app-configuration';
import { DefaultAzureCredential } from '@azure/identity';

/**
 * Fetches application configuration from Azure App Configuration.
 *
 * AZURE_APP_CONFIG_ENDPOINT is infrastructure config (not a secret) and
 * is injected as a plain environment variable on the Container App.
 *
 * @returns {Promise<{ auth0Domain: string, auth0Audience: string, cosmosDbEndpoint: string }>}
 */
export async function fetchAppConfig() {
  const endpoint = process.env.AZURE_APP_CONFIG_ENDPOINT;

  if (!endpoint) {
    throw new Error(
      'AZURE_APP_CONFIG_ENDPOINT environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const prefix = process.env.APP_CONFIG_PREFIX;

  if (!prefix) {
    throw new Error(
      'APP_CONFIG_PREFIX environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const credential = new DefaultAzureCredential();
  const client = new AppConfigurationClient(endpoint, credential);

  const [domainSetting, audienceSetting, cosmosEndpointSetting] = await Promise.all([
    client.getConfigurationSetting({ key: 'AUTH0_DOMAIN' }),
    client.getConfigurationSetting({ key: `${prefix}/AUTH0_AUDIENCE` }),
    client.getConfigurationSetting({ key: 'cosmos_db_endpoint' }),
  ]);

  const auth0Domain = domainSetting.value;
  const auth0Audience = audienceSetting.value;
  const cosmosDbEndpoint = cosmosEndpointSetting.value;

  if (!auth0Domain || !auth0Audience || !cosmosDbEndpoint) {
    throw new Error(
      `Azure App Configuration is missing required keys. ` +
      `Ensure AUTH0_DOMAIN, ${prefix}/AUTH0_AUDIENCE, and cosmos_db_endpoint are set in the store.`
    );
  }

  console.log('[appConfig] Application config fetched from Azure App Configuration');
  return { auth0Domain, auth0Audience, cosmosDbEndpoint };
}


--- File: my-homepage\frontend\auth.js ---
/* global auth0, CONFIG */

let auth0Client = null;

async function initAuth() {
  auth0Client = await auth0.createAuth0Client({
    domain: CONFIG.auth0Domain,
    clientId: CONFIG.auth0ClientId,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: CONFIG.auth0Audience,
    },
  });

  // Handle redirect callback
  const query = window.location.search;
  if (query.includes("code=") && query.includes("state=")) {
    await auth0Client.handleRedirectCallback();
    window.history.replaceState({}, document.title, window.location.pathname);
  }

  return auth0Client;
}

async function login() {
  await auth0Client.loginWithRedirect();
}

async function logout() {
  await auth0Client.logout({
    logoutParams: { returnTo: window.location.origin },
  });
}

async function getToken() {
  return auth0Client.getTokenSilently({
    authorizationParams: { audience: CONFIG.auth0Audience },
  });
}

async function isAuthenticated() {
  return auth0Client.isAuthenticated();
}

async function getUser() {
  return auth0Client.getUser();
}


--- File: my-homepage\frontend\bookmarks.js ---
const bookmarks = [
  {
    name: "Home",
    children: [
      {
        name: "Voice",
        url: "http://voice.google.com/u/0/messages"
      },
      {
        name: "Chess",
        url: "https://www.chess.com/"
      },
      {
        name: "Reddit",
        url: "https://www.reddit.com/"
      },
      {
        name: "YouTube",
        url: "https://www.youtube.com/"
      },
      {
        name: "Google",
        url: "http://google.com/"
      },
      {
        name: "Workout",
        url: "https://docs.google.com/spreadsheets/d/1qdizKHXq5e465dt5ChbcKsGTYG6QmjON/edit?gid=1734961154#gid=1734961154"
      },
      {
        name: "Google Calendar",
        url: "https://calendar.google.com/calendar/u/0/r"
      },
      {
        name: "Amazon",
        url: "https://www.amazon.com/"
      },
      {
        name: "Nelsonhub",
        url: "http://192.168.50.131/"
      }
    ]
  },
  {
    name: "Projects",
    children: [
      {
        name: "Spacelift",
        url: "https://nelsong6.app.spacelift.io/stack/new-pokemon-appeared/run/01K4JKE4EGWVCRKAB6BZ6RXHJB"
      },
      {
        name: "Azure",
        url: "https://portal.azure.com/#home"
      },
      {
        name: "New Pokemon Appears",
        url: "https://github.com/nelsong6/new-pokemon-appeared/milestone/4"
      }
    ]
  },
  {
    name: "Bills",
    children: [
      {
        name: "Ameriprise",
        url: "https://www.ameriprise.com/client-login"
      },
      {
        name: "Chase",
        url: "https://www.chase.com/"
      },
      {
        name: "Loancare",
        url: "https://myloancare.com/web/home"
      },
      {
        name: "Water Delivery",
        url: "https://drink.water.com/"
      },
      {
        name: "Haircut",
        url: "https://www.vagaro.com/roots66salons"
      }
    ]
  },
  {
    name: "Dev",
    children: [
      {
        name: "Auth0",
        url: "http://auth0.com/"
      },
      {
        name: "Github",
        url: "https://github.com/nelsong6"
      },
      {
        name: "Spacelift",
        url: "https://nelsong6.app.us.spacelift.io/dashboard"
      },
      {
        name: "Claude",
        url: "https://platform.claude.com/"
      }
    ]
  }
];

--- File: my-homepage\frontend\bookmarks.js.example ---
const bookmarks = [
  {
    name: "Social",
    children: [
      { name: "Twitter", url: "https://twitter.com" },
      { name: "Reddit", url: "https://reddit.com" },
      { name: "YouTube", url: "https://youtube.com" },
    ],
  },
  {
    name: "Dev",
    url: "https://github.com",
    children: [
      { name: "GitHub", url: "https://github.com" },
      { name: "Stack Overflow", url: "https://stackoverflow.com" },
      { name: "MDN Web Docs", url: "https://developer.mozilla.org" },
    ],
  },
  {
    name: "News",
    children: [
      { name: "Hacker News", url: "https://news.ycombinator.com" },
      { name: "Lobsters", url: "https://lobste.rs" },
    ],
  },
  {
    name: "Tools",
    children: [
      {
        name: "Search",
        children: [
          { name: "Google", url: "https://google.com" },
          { name: "DuckDuckGo", url: "https://duckduckgo.com" },
        ],
      },
      { name: "Email", url: "https://mail.google.com" },
    ],
  },
];


--- File: my-homepage\frontend\config.js.example ---
const CONFIG = {
  auth0Domain: "<AUTH0_DOMAIN>",
  auth0ClientId: "<AUTH0_CLIENT_ID>",
  auth0Audience: "<AUTH0_AUDIENCE>",
  apiUrl: "http://localhost:3000",
};


--- File: my-homepage\frontend\generate-config.sh ---
#!/bin/bash
# Generates frontend/config.js from environment variables.
#
# Usage (local dev):
#   source backend/.env     # or export the vars manually
#   export AUTH0_DOMAIN="dev-gtdi5x5p0nmticqd.us.auth0.com"
#   export AUTH0_CLIENT_ID="<your-client-id>"
#   export AUTH0_AUDIENCE="https://homepage.api.yourdomain.com"
#   export API_URL="https://homepage.api.yourdomain.com"
#   bash frontend/generate-config.sh
#
# In the CI/CD pipeline, these variables should be set from Terraform outputs
# or Azure App Configuration before this script runs.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

: "${AUTH0_DOMAIN:?ERROR: AUTH0_DOMAIN is not set}"
: "${AUTH0_CLIENT_ID:?ERROR: AUTH0_CLIENT_ID is not set}"
: "${AUTH0_AUDIENCE:?ERROR: AUTH0_AUDIENCE is not set}"
: "${API_URL:?ERROR: API_URL is not set}"

cat <<EOF > "$SCRIPT_DIR/config.js"
const CONFIG = {
  auth0Domain: "${AUTH0_DOMAIN}",
  auth0ClientId: "${AUTH0_CLIENT_ID}",
  auth0Audience: "${AUTH0_AUDIENCE}",
  apiUrl: "${API_URL}",
};
EOF

echo "Successfully generated $SCRIPT_DIR/config.js"


--- File: my-homepage\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Login screen -->
  <div id="login-screen">
    <div class="login-box">
      <h1>Home</h1>
      <button id="login-btn">Log In</button>
    </div>
  </div>

  <!-- Loading state -->
  <div id="loading" class="hidden">Loading…</div>

  <!-- Main app (hidden until authenticated) -->
  <div id="app" class="hidden">
    <div id="toolbar">
      <button id="expand-all">Expand All</button>
      <button id="collapse-all">Collapse All</button>
      <div id="user-info">
        <span id="user-email"></span>
        <button id="logout-btn">Log Out</button>
      </div>
    </div>
    <div id="tree"></div>
  </div>

  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
  <script src="config.js"></script>
  <script src="auth.js"></script>
  <script src="script.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js");
    }
  </script>
</body>
</html>


--- File: my-homepage\frontend\script.js ---
/* global CONFIG, initAuth, login, logout, getToken, isAuthenticated, getUser */

// ── DOM references ──────────────────────────────────────────────
const loginScreen = document.getElementById("login-screen");
const loadingEl = document.getElementById("loading");
const appEl = document.getElementById("app");
const tree = document.getElementById("tree");

const CACHE_KEY = "cached_bookmarks";

// ── App entry point ─────────────────────────────────────────────

(async function main() {
  const cached = loadCachedBookmarks();

  // If we have cached data, paint immediately — no waiting for Auth0.
  if (cached) {
    loginScreen.classList.add("hidden");
    loadingEl.classList.add("hidden");
    appEl.classList.remove("hidden");
    renderBookmarks(cached);
  } else {
    // No cache — show loading while Auth0 initializes
    loginScreen.classList.add("hidden");
    loadingEl.classList.remove("hidden");
  }

  // Auth0 init happens in the background while cached UI is already visible.
  await initAuth();

  if (await isAuthenticated()) {
    await showApp(cached);
  } else if (cached) {
    // Had stale cache but session expired — fall back to login
    showLogin();
  } else {
    showLogin();
  }
})();

// ── Auth flows ──────────────────────────────────────────────────

function showLogin() {
  loadingEl.classList.add("hidden");
  appEl.classList.add("hidden");
  loginScreen.classList.remove("hidden");
}

async function showApp(alreadyRenderedCache) {
  loadingEl.classList.add("hidden");
  loginScreen.classList.add("hidden");
  appEl.classList.remove("hidden");

  // Show user email
  const user = await getUser();
  document.getElementById("user-email").textContent = user.email || user.name || "";

  // Fetch fresh bookmarks from API (background revalidation)
  const fresh = await fetchBookmarks();

  // Only re-render if the data actually changed (or if we had no cache)
  if (!alreadyRenderedCache || !bookmarksEqual(alreadyRenderedCache, fresh)) {
    saveCachedBookmarks(fresh);
    renderBookmarks(fresh);
  }
}

// ── localStorage helpers ────────────────────────────────────────

function loadCachedBookmarks() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

function saveCachedBookmarks(bookmarks) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(bookmarks));
  } catch {
    // Storage full or unavailable — non-critical
  }
}

function bookmarksEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

// ── API ─────────────────────────────────────────────────────────

async function fetchBookmarks() {
  try {
    const token = await getToken();
    const res = await fetch(`${CONFIG.apiUrl}/api/bookmarks`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error(`API error: ${res.status}`);

    const data = await res.json();
    return data.bookmarks || [];
  } catch (err) {
    console.error("Failed to fetch bookmarks:", err);
    // On network failure, return whatever we have cached
    return loadCachedBookmarks() || [];
  }
}

// ── Rendering ───────────────────────────────────────────────────

function renderBookmarks(bookmarks) {
  tree.innerHTML = "";

  if (bookmarks.length === 0) {
    tree.textContent = "No bookmarks yet.";
    return;
  }

  tree.style.setProperty(
    "--url-left",
    Math.ceil(calcMaxRowWidth(bookmarks, "")) + 2 + "ch"
  );
  tree.appendChild(renderList(bookmarks, ""));
}

// Calculate the max visual width of all tree rows (in ch units) so
// hover-revealed URLs can be aligned in a single consistent column.
function calcMaxRowWidth(items, prefix) {
  let max = 0;
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;
    // prefix+connector chars + toggle/spacer (1ch + 0.6ch gap) + name + arrow if link
    const width = (prefix + connector).length + 1.6 + item.name.length + (item.url ? 1.15 : 0);
    if (width > max) max = width;
    if (hasChildren) {
      const childMax = calcMaxRowWidth(item.children, childPrefix);
      if (childMax > max) max = childMax;
    }
  });
  return max;
}

// Build DOM for a list of sibling nodes.
// `prefix` is the inherited string of "│   " / "    " segments from ancestors.
function renderList(items, prefix) {
  const frag = document.createDocumentFragment();
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;

    // Row
    const row = document.createElement("div");
    row.className = "node";

    // Prefix (inherited tree lines)
    const pre = document.createElement("span");
    pre.className = "node-prefix";
    pre.textContent = prefix + connector;
    row.appendChild(pre);

    // Toggle button or spacer
    if (hasChildren) {
      const btn = document.createElement("button");
      btn.className = "node-toggle";
      btn.textContent = ">";
      btn.setAttribute("aria-label", "expand");
      row.appendChild(btn);
    } else {
      const spacer = document.createElement("span");
      spacer.className = "node-spacer";
      row.appendChild(spacer);
    }

    // Label
    const label = document.createElement("span");
    label.className = "node-label" + (hasChildren ? " folder" : "");
    if (item.url) {
      const a = document.createElement("a");
      a.href = item.url;
      a.textContent = item.name;
      label.appendChild(a);
      const arrow = document.createElement("span");
      arrow.className = "link-indicator";
      arrow.textContent = "↗";
      arrow.setAttribute("aria-hidden", "true");
      label.appendChild(arrow);
    } else {
      label.textContent = item.name;
    }
    row.appendChild(label);

    // URL hint shown on hover
    if (item.url) {
      const urlSpan = document.createElement("span");
      urlSpan.className = "node-url";
      urlSpan.textContent = item.url;
      row.appendChild(urlSpan);
    }

    frag.appendChild(row);

    // Children
    if (hasChildren) {
      const childrenContainer = document.createElement("div");
      childrenContainer.className = "children";
      childrenContainer.appendChild(renderList(item.children, childPrefix));
      frag.appendChild(childrenContainer);

      // Wire toggle — whole row triggers expand/collapse
      const btn = row.querySelector(".node-toggle");
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        // If click landed on a link, let it navigate instead of toggling
        if (e.target.closest("a")) return;
        const open = childrenContainer.classList.toggle("open");
        btn.classList.toggle("open", open);
        btn.textContent = open ? "v" : ">";
        btn.setAttribute("aria-label", open ? "collapse" : "expand");
      });
    } else if (item.url) {
      // Wire link — whole row navigates
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        if (e.target.tagName === "A") return; // let native <a> handle itself
        window.location.href = item.url;
      });
    }
  });
  return frag;
}

// ── Toolbar ─────────────────────────────────────────────────────

document.getElementById("expand-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.add("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.add("open");
    btn.textContent = "v";
    btn.setAttribute("aria-label", "collapse");
  });
});

document.getElementById("collapse-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.remove("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.remove("open");
    btn.textContent = ">";
    btn.setAttribute("aria-label", "expand");
  });
});

document.getElementById("login-btn").addEventListener("click", login);
document.getElementById("logout-btn").addEventListener("click", logout);


--- File: my-homepage\tofu\appconfig.tf ---
# ============================================================================
# Azure App Configuration Key-Values
# ============================================================================
# These keys are read at runtime by the backend via fetchAppConfig() in
# backend/startup/appConfig.js. The Container App's managed identity has the
# "App Configuration Data Reader" role assigned in backend.tf.

resource "azurerm_app_configuration_key" "auth0_domain" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "AUTH0_DOMAIN"
  value                  = "dev-gtdi5x5p0nmticqd.us.auth0.com"
}

resource "azurerm_app_configuration_key" "auth0_audience" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "${local.front_app_dns_name}/AUTH0_AUDIENCE"
  value                  = auth0_resource_server.backend_api.identifier
}


--- File: my-homepage\tofu\backend.tf ---
# ============================================================================
# Azure Container Apps (Serverless Container Hosting)
# ============================================================================

locals {
  back_app_dns_name = "${local.front_app_dns_name}.api"
}

# Container App for the backend API
resource "azurerm_container_app" "homepage_api" {
  for_each = toset(["homepage-api"]) # Add more backend APIs here if needed
  name                         = each.key
  resource_group_name          = azurerm_resource_group.homepage.name
  container_app_environment_id = var.container_app_environment_id
  revision_mode                = "Single"

  # Enable system-assigned managed identity
  identity {
    type = "SystemAssigned"
  }

  # Container configuration
  template {
    container {
      name   = each.key
      image  = "ghcr.io/nelsong6/${terraform.workspace}/${each.key}:latest"
      cpu    = 0.25
      memory = "0.5Gi"

      env {
        name  = "PORT"
        value = "3000"
      }

      env {
        name  = "AZURE_APP_CONFIG_ENDPOINT"
        value = var.azure_app_config_endpoint
      }

      env {
        name  = "APP_CONFIG_PREFIX"
        value = local.front_app_dns_name
      }
    }

    min_replicas = 0 # Scale to zero when not in use
    max_replicas = 3
  }

  # Ingress configuration
  ingress {
    external_enabled = true
    target_port      = 3000

    traffic_weight {
      latest_revision = true
      percentage      = 100
    }

    cors {
      allowed_origins = [
        # Production: Default Azure hostname
        "https://${azurerm_static_web_app.homepage.default_host_name}",
        "https://${local.front_app_dns_name}.${var.dns_zone_name}",

        # Development: Localhost
        "http://localhost:3000",
        "http://localhost:5500"
      ]

      allowed_methods           = ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"]
      allowed_headers           = ["*"]
      exposed_headers           = ["*"]
      max_age_in_seconds        = 3600
      allow_credentials_enabled = true
    }
  }
}

# Grant Container App managed identity access to Cosmos DB
resource "azurerm_cosmosdb_sql_role_assignment" "container_app_cosmos" {
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  role_definition_id  = "${var.cosmos_db_account_id}/sqlRoleDefinitions/00000000-0000-0000-0000-000000000002" # Built-in Data Contributor
  principal_id        = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
  scope               = var.cosmos_db_account_id
}

# Grant Container App managed identity read access to Azure App Configuration
resource "azurerm_role_assignment" "container_app_appconfig_reader" {
  scope                = var.azure_app_config_resource_id
  role_definition_name = "App Configuration Data Reader"
  principal_id         = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
}

# 1. The Verification Record (Proves to Azure you own the domain)
resource "azurerm_dns_txt_record" "homepage_api_verification" {
  name                = "asuid.${local.back_app_dns_name}"
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600

  record {
    value = azurerm_container_app.homepage_api["homepage-api"].custom_domain_verification_id
  }
}

# 2. The Routing Record (Points to the container ingress)
resource "azurerm_dns_cname_record" "homepage_api" {
  name                = local.back_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_container_app.homepage_api["homepage-api"].ingress[0].fqdn
}

# 3. The Custom Domain (Unsecured initially)
resource "azurerm_container_app_custom_domain" "homepage_api" {
  name             = "${local.back_app_dns_name}.${var.dns_zone_name}"
  container_app_id = azurerm_container_app.homepage_api["homepage-api"].id

  # We must completely omit the certificate binding fields and tell Terraform
  # to ignore them, so it doesn't destroy the cert once Azure generates it.
  lifecycle {
    ignore_changes = [
      certificate_binding_type,
      container_app_environment_certificate_id
    ]
  }

  depends_on = [
    azurerm_dns_txt_record.homepage_api_verification,
    azurerm_dns_cname_record.homepage_api
  ]
}

# 4. The Auth0 Resource Server
resource "auth0_resource_server" "backend_api" {
  name        = "My Homepage Backend API"
  identifier  = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  signing_alg = "RS256"

  # Allows the frontend to request refresh tokens so users stay logged in
  allow_offline_access = true

  # Prevents the consent prompt since you own both the frontend and backend.
  skip_consent_for_verifiable_first_party_clients = true
}


--- File: my-homepage\tofu\db.tf ---
# Cosmos DB NoSQL Database (app-specific; account is managed by shared infra)
resource "azurerm_cosmosdb_sql_database" "homepage" {
  name                = "HomepageDB"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name

  lifecycle {
    ignore_changes = [throughput]
  }
}

resource "azurerm_cosmosdb_sql_container" "userdata" {
  name                = "userdata"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  database_name       = azurerm_cosmosdb_sql_database.homepage.name
  partition_key_paths = ["/userId"]

  indexing_policy {
    indexing_mode = "consistent"

    included_path {
      path = "/*"
    }
  }
}


--- File: my-homepage\tofu\frontend.tf ---
resource "azurerm_static_web_app" "homepage" {
  name                = "homepage-app"
  resource_group_name = azurerm_resource_group.homepage.name
  location            = azurerm_resource_group.homepage.location
  sku_tier            = "Free"
  sku_size            = "Free"
  lifecycle {
    ignore_changes = [
      repository_url,
      repository_branch
    ]
  }
}

locals {
  front_app_dns_name = "homepage"
}

resource "azurerm_dns_cname_record" "homepage" {
  name                = local.front_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_static_web_app.homepage.default_host_name
}

resource "azurerm_static_web_app_custom_domain" "homepage" {
  static_web_app_id = azurerm_static_web_app.homepage.id
  domain_name       = "${local.front_app_dns_name}.${var.dns_zone_name}"
  validation_type   = "cname-delegation"
  depends_on        = [azurerm_dns_cname_record.homepage]
}

resource "auth0_client" "frontend_spa" {
  name           = "My Homepage Web UI"
  app_type       = "spa"
  is_first_party = true
  callbacks = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  allowed_logout_urls = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  web_origins = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  jwt_configuration {
    alg = "RS256"
  }
  grant_types = [
    "authorization_code",
    "implicit",
    "refresh_token"
  ]
}


--- File: my-homepage\tofu\keyvault.tf ---
# ============================================================================
# Azure Key Vault (data source)
# ============================================================================
# Reads secrets from the shared Key Vault created by the bootstrap script.
# The vault name is passed via the Spacelift global context (TF_VAR_key_vault_name).

data "azurerm_key_vault" "main" {
  name                = var.key_vault_name
  resource_group_name = var.resource_group_name
}

data "azurerm_key_vault_secret" "auth0_client_secret" {
  name         = "auth0-client-secret"
  key_vault_id = data.azurerm_key_vault.main.id
}


--- File: my-homepage\tofu\main.tf ---
resource "azurerm_resource_group" "homepage" {
  name     = "homepage-rg"
  location = var.location
}

resource "terraform_data" "cd_webhook_trigger" {
  input = var.spacelift_commit_sha
}


--- File: my-homepage\tofu\outputs.tf ---
# Outputs
output "resource_group_name" {
  value       = azurerm_resource_group.homepage.name
  description = "Name of the resource group"
}

output "static_web_app_name" {
  value       = azurerm_static_web_app.homepage.name
  description = "Name of the Azure Static Web App"
}

output "static_web_app_default_hostname" {
  value       = azurerm_static_web_app.homepage.default_host_name
  description = "Default hostname of the Static Web App"
}

output "cosmos_db_name" {
  value       = var.cosmos_db_account_name
  description = "Cosmos DB account name"
}

output "cosmos_db_database_name" {
  value       = azurerm_cosmosdb_sql_database.homepage.name
  description = "Cosmos DB database name"
}

output "cosmos_db_container_name" {
  value       = azurerm_cosmosdb_sql_container.userdata.name
  description = "Cosmos DB container name for user data"
}

output "backend_api_url" {
  value       = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  description = "The URL of the backend Container App API"
}

output "container_app_name" {
  value       = azurerm_container_app.homepage_api["homepage-api"].name
  description = "Name of the backend Container App, picked up by github actions to handle custom dns for container app."
}

output "auth0_domain" {
  value       = azurerm_app_configuration_key.auth0_domain.value
  description = "Auth0 tenant domain"
}

output "auth0_client_id" {
  value       = auth0_client.frontend_spa.client_id
  description = "Auth0 SPA client ID for the frontend application"
}

output "auth0_audience" {
  value       = auth0_resource_server.backend_api.identifier
  description = "Auth0 API audience identifier for the backend"
}

output "app_config_prefix" {
  value       = local.front_app_dns_name
  description = "App Configuration key prefix, derived from the frontend DNS name"
}


--- File: my-homepage\tofu\provider.tf ---
provider "azurerm" {
  features {}
  use_oidc = true
}

provider "auth0" {
  domain        = "dev-gtdi5x5p0nmticqd.us.auth0.com"
  client_id     = "7qsN7zrBAh7TwhjEUcgtU46yOSs9TXbg"
  client_secret = data.azurerm_key_vault_secret.auth0_client_secret.value
}


--- File: my-homepage\tofu\variables.tf ---
# ============================================================================
# Application Variables
# ============================================================================

variable "location" {
  description = "Azure region where the resource group will be created"
  type        = string
  default     = "westus2"
}

variable "key_vault_name" {
  description = "Name of the shared Key Vault"
  type        = string
}

# ============================================================================
# Shared Infrastructure Variables
# ============================================================================

variable "resource_group_name" {
  description = "Name of the shared resource group"
  type        = string
}

variable "resource_group_location" {
  description = "Location of the shared resource group"
  type        = string
}

variable "resource_group_id" {
  description = "ID of the shared resource group"
  type        = string
}

variable "dns_zone_name" {
  description = "Name of the DNS zone"
  type        = string
}

variable "dns_zone_id" {
  description = "ID of the DNS zone"
  type        = string
}

variable "container_app_environment_name" {
  description = "Name of the Container App Environment"
  type        = string
}

variable "container_app_environment_id" {
  description = "ID of the Container App Environment"
  type        = string
}

variable "cosmos_db_account_name" {
  description = "Name of the Cosmos DB account"
  type        = string
}

variable "cosmos_db_account_id" {
  description = "ID of the Cosmos DB account"
  type        = string
}

variable "spacelift_commit_sha" {
  description = "The Git SHA passed dynamically from Spacelift to force an apply"
  type        = string
}

variable "azure_app_config_endpoint" {
  description = "Endpoint URL of the Azure App Configuration store (e.g. https://<store>.azconfig.io)"
  type        = string
}

variable "azure_app_config_resource_id" {
  description = "Resource ID of the Azure App Configuration store (used for RBAC role assignment)"
  type        = string
}


