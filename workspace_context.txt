=============================================================
WORKSPACE FOLDER: my-homepage
=============================================================

--- File: my-homepage\.gitignore ---
frontend/config.js
frontend/bookmarks.js
backend/.env
backend/node_modules/


--- File: my-homepage\workspace_context.txt ---


--- File: my-homepage\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: my-homepage\.github\workflows\container-app-build.yml ---
# Test 6
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
      app_name: 'homepage-api'
      dockerfile_path: 'backend/Dockerfile'
      context: 'backend'
    secrets: inherit

--- File: my-homepage\.github\workflows\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ inputs.commit_sha }}
      app_name: 'homepage-api'
      frontend_dir: 'frontend'
    secrets: inherit

--- File: my-homepage\.github\workflows\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: my-homepage\.github\workflows\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: my-homepage\.github\workflows\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

--- File: my-homepage\backend\.env ---
AZURE_APP_CONFIG_ENDPOINT=https://infra-appconfig.azconfig.io
APP_CONFIG_PREFIX=homepage
AZURE_TENANT_ID="2236b5e4-81d2-4d82-bde5-17b1037999ea"


--- File: my-homepage\backend\package.json ---
{
  "name": "my-homepage-api",
  "version": "1.0.0",
  "type": "module",
  "description": "My Homepage Backend API with Azure Cosmos DB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "license": "MIT",
  "dependencies": {
    "@azure/app-configuration": "^1.11.0",
    "@azure/cosmos": "^4.0.0",
    "@azure/identity": "^4.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2",
    "express-oauth2-jwt-bearer": "^1.7.4",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}


--- File: my-homepage\backend\server.js ---
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import cors from 'cors';
import { CosmosClient } from '@azure/cosmos';
import { DefaultAzureCredential } from '@azure/identity';
import { createRequireAuth } from './middleware/auth.js';
import { fetchAppConfig } from './startup/appConfig.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware that does NOT depend on async config — safe to register now
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

async function startServer() {
  // Step 1: Fetch AUTH0_DOMAIN and AUTH0_AUDIENCE from Azure App Configuration.
  const { auth0Domain, auth0Audience, cosmosDbEndpoint } = await fetchAppConfig();

  // Step 2: Build the Auth0 JWT middleware now that we have the values.
  const requireAuth = createRequireAuth({ auth0Domain, auth0Audience });

  // Step 3: Initialize Cosmos DB client.
  const DATABASE_NAME = process.env.COSMOS_DB_DATABASE_NAME || 'HomepageDB';
  const CONTAINER_NAME = process.env.COSMOS_DB_CONTAINER_NAME || 'userdata';

  let container;
  try {
    const credential = new DefaultAzureCredential();
    const client = new CosmosClient({
      endpoint: cosmosDbEndpoint,
      aadCredentials: credential
    });

    const database = client.database(DATABASE_NAME);
    container = database.container(CONTAINER_NAME);
    console.log('Connected to Cosmos DB using Azure Identity');
  } catch (error) {
    console.error('Failed to connect to Cosmos DB:', error);
    process.exit(1);
  }

  // Step 4: Register all routes.

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: DATABASE_NAME,
      container: CONTAINER_NAME
    });
  });

  // Database initialization endpoint
  app.post('/api/admin/init-database', requireAuth, async (req, res) => {
    try {
      const credential = new DefaultAzureCredential();
      const client = new CosmosClient({
        endpoint: cosmosDbEndpoint,
        aadCredentials: credential
      });

      // Create database if it doesn't exist
      const { database } = await client.databases.createIfNotExists({
        id: DATABASE_NAME
      });

      // Create container if it doesn't exist
      const { container: newContainer } = await database.containers.createIfNotExists({
        id: CONTAINER_NAME,
        partitionKey: {
          paths: ['/userId']
        }
      });

      // Optionally seed bookmarks for the current user
      const userId = req.auth.payload.sub;
      let seeded = false;

      if (req.body.bookmarks) {
        const bookmarksDoc = {
          id: `bookmarks_${userId}`,
          userId,
          type: 'bookmarks',
          bookmarks: req.body.bookmarks,
          updatedAt: new Date().toISOString()
        };
        await newContainer.items.upsert(bookmarksDoc);
        seeded = true;
      }

      res.json({
        success: true,
        message: 'Database initialized successfully',
        database: DATABASE_NAME,
        container: CONTAINER_NAME,
        seeded
      });
    } catch (error) {
      console.error('Error initializing database:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize database',
        message: error.message
      });
    }
  });

  // Get bookmarks for the authenticated user
  app.get('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;

      const querySpec = {
        query: 'SELECT * FROM c WHERE c.type = @type AND c.userId = @userId',
        parameters: [
          { name: '@type', value: 'bookmarks' },
          { name: '@userId', value: userId }
        ]
      };

      const { resources } = await container.items.query(querySpec).fetchAll();

      if (resources.length === 0) {
        return res.json({ bookmarks: [] });
      }

      res.json({ bookmarks: resources[0].bookmarks });
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ error: 'Failed to fetch bookmarks', message: error.message });
    }
  });

  // Save/update bookmarks for the authenticated user
  app.put('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;
      const { bookmarks } = req.body;

      if (!Array.isArray(bookmarks)) {
        return res.status(400).json({ error: 'Request body must contain a bookmarks array' });
      }

      const bookmarksDoc = {
        id: `bookmarks_${userId}`,
        userId,
        type: 'bookmarks',
        bookmarks,
        updatedAt: new Date().toISOString()
      };

      const { resource } = await container.items.upsert(bookmarksDoc);

      res.json({ bookmarks: resource.bookmarks, updatedAt: resource.updatedAt });
    } catch (error) {
      console.error('Error saving bookmarks:', error);
      res.status(500).json({ error: 'Failed to save bookmarks', message: error.message });
    }
  });

  // In production, serve frontend static files
  if (process.env.NODE_ENV === 'production') {
    app.use(express.static('../frontend'));
  }

  // 404 handler
  app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
  });

  // Error handler
  app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error', message: err.message });
  });

  // Step 5: Start listening only after all setup is complete.
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`Database: ${DATABASE_NAME}`);
    console.log(`Container: ${CONTAINER_NAME}`);
    console.log(`Auth0 domain: ${auth0Domain}`);
    console.log(`Health check: http://localhost:${PORT}/health`);
  });
}

startServer().catch((error) => {
  console.error('Fatal startup error:', error);
  process.exit(1);
});

export default app;


--- File: my-homepage\backend\middleware\auth.js ---
import { auth } from 'express-oauth2-jwt-bearer';

/**
 * Creates the Auth0 JWT validation middleware.
 *
 * Must be called after Azure App Configuration values are fetched,
 * because auth() is a synchronous factory that reads its arguments immediately.
 *
 * @param {{ auth0Domain: string, auth0Audience: string }} config
 * @returns {import('express').RequestHandler}
 */
export function createRequireAuth({ auth0Domain, auth0Audience }) {
  return auth({
    audience: auth0Audience,
    issuerBaseURL: `https://${auth0Domain}/`,
    tokenSigningAlg: 'RS256',
  });
}


--- File: my-homepage\backend\startup\appConfig.js ---
import { AppConfigurationClient } from '@azure/app-configuration';
import { DefaultAzureCredential } from '@azure/identity';

/**
 * Fetches application configuration from Azure App Configuration.
 *
 * AZURE_APP_CONFIG_ENDPOINT is infrastructure config (not a secret) and
 * is injected as a plain environment variable on the Container App.
 *
 * @returns {Promise<{ auth0Domain: string, auth0Audience: string, cosmosDbEndpoint: string }>}
 */
export async function fetchAppConfig() {
  const endpoint = process.env.AZURE_APP_CONFIG_ENDPOINT;

  if (!endpoint) {
    throw new Error(
      'AZURE_APP_CONFIG_ENDPOINT environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const prefix = process.env.APP_CONFIG_PREFIX;

  if (!prefix) {
    throw new Error(
      'APP_CONFIG_PREFIX environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const credential = new DefaultAzureCredential();
  const client = new AppConfigurationClient(endpoint, credential);

  const [domainSetting, audienceSetting, cosmosEndpointSetting] = await Promise.all([
    client.getConfigurationSetting({ key: 'AUTH0_DOMAIN' }),
    client.getConfigurationSetting({ key: `${prefix}/AUTH0_AUDIENCE` }),
    client.getConfigurationSetting({ key: 'cosmos_db_endpoint' }),
  ]);

  const auth0Domain = domainSetting.value;
  const auth0Audience = audienceSetting.value;
  const cosmosDbEndpoint = cosmosEndpointSetting.value;

  if (!auth0Domain || !auth0Audience || !cosmosDbEndpoint) {
    throw new Error(
      `Azure App Configuration is missing required keys. ` +
      `Ensure AUTH0_DOMAIN, ${prefix}/AUTH0_AUDIENCE, and cosmos_db_endpoint are set in the store.`
    );
  }

  console.log('[appConfig] Application config fetched from Azure App Configuration');
  return { auth0Domain, auth0Audience, cosmosDbEndpoint };
}


--- File: my-homepage\frontend\auth.js ---
/* global auth0 */
import { CONFIG } from './config.js';

let auth0Client = null;

export async function initAuth() {
  auth0Client = await auth0.createAuth0Client({
    domain: CONFIG.auth0Domain,
    clientId: CONFIG.auth0ClientId,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: CONFIG.auth0Audience,
    },
  });

  // Handle redirect callback
  const query = window.location.search;
  if (query.includes("code=") && query.includes("state=")) {
    await auth0Client.handleRedirectCallback();
    window.history.replaceState({}, document.title, window.location.pathname);
  }

  return auth0Client;
}

export async function login() {
  await auth0Client.loginWithRedirect();
}

export async function logout() {
  await auth0Client.logout({
    logoutParams: { returnTo: window.location.origin },
  });
}

export async function getToken() {
  return auth0Client.getTokenSilently({
    authorizationParams: { audience: CONFIG.auth0Audience },
  });
}

export async function isAuthenticated() {
  return auth0Client.isAuthenticated();
}

export async function getUser() {
  return auth0Client.getUser();
}


--- File: my-homepage\frontend\bookmarks.js ---
const bookmarks = [
  {
    name: "Home",
    children: [
      {
        name: "Voice",
        url: "http://voice.google.com/u/0/messages"
      },
      {
        name: "Chess",
        url: "https://www.chess.com/"
      },
      {
        name: "Reddit",
        url: "https://www.reddit.com/"
      },
      {
        name: "YouTube",
        url: "https://www.youtube.com/"
      },
      {
        name: "Google",
        url: "http://google.com/"
      },
      {
        name: "Workout",
        url: "https://docs.google.com/spreadsheets/d/1qdizKHXq5e465dt5ChbcKsGTYG6QmjON/edit?gid=1734961154#gid=1734961154"
      },
      {
        name: "Google Calendar",
        url: "https://calendar.google.com/calendar/u/0/r"
      },
      {
        name: "Amazon",
        url: "https://www.amazon.com/"
      },
      {
        name: "Nelsonhub",
        url: "http://192.168.50.131/"
      }
    ]
  },
  {
    name: "Projects",
    children: [
      {
        name: "Spacelift",
        url: "https://nelsong6.app.spacelift.io/stack/new-pokemon-appeared/run/01K4JKE4EGWVCRKAB6BZ6RXHJB"
      },
      {
        name: "Azure",
        url: "https://portal.azure.com/#home"
      },
      {
        name: "New Pokemon Appears",
        url: "https://github.com/nelsong6/new-pokemon-appeared/milestone/4"
      }
    ]
  },
  {
    name: "Bills",
    children: [
      {
        name: "Ameriprise",
        url: "https://www.ameriprise.com/client-login"
      },
      {
        name: "Chase",
        url: "https://www.chase.com/"
      },
      {
        name: "Loancare",
        url: "https://myloancare.com/web/home"
      },
      {
        name: "Water Delivery",
        url: "https://drink.water.com/"
      },
      {
        name: "Haircut",
        url: "https://www.vagaro.com/roots66salons"
      }
    ]
  },
  {
    name: "Dev",
    children: [
      {
        name: "Auth0",
        url: "http://auth0.com/"
      },
      {
        name: "Github",
        url: "https://github.com/nelsong6"
      },
      {
        name: "Spacelift",
        url: "https://nelsong6.app.us.spacelift.io/dashboard"
      },
      {
        name: "Claude",
        url: "https://platform.claude.com/"
      }
    ]
  }
];

--- File: my-homepage\frontend\bookmarks.js.example ---
const bookmarks = [
  {
    name: "Social",
    children: [
      { name: "Twitter", url: "https://twitter.com" },
      { name: "Reddit", url: "https://reddit.com" },
      { name: "YouTube", url: "https://youtube.com" },
    ],
  },
  {
    name: "Dev",
    url: "https://github.com",
    children: [
      { name: "GitHub", url: "https://github.com" },
      { name: "Stack Overflow", url: "https://stackoverflow.com" },
      { name: "MDN Web Docs", url: "https://developer.mozilla.org" },
    ],
  },
  {
    name: "News",
    children: [
      { name: "Hacker News", url: "https://news.ycombinator.com" },
      { name: "Lobsters", url: "https://lobste.rs" },
    ],
  },
  {
    name: "Tools",
    children: [
      {
        name: "Search",
        children: [
          { name: "Google", url: "https://google.com" },
          { name: "DuckDuckGo", url: "https://duckduckgo.com" },
        ],
      },
      { name: "Email", url: "https://mail.google.com" },
    ],
  },
];


--- File: my-homepage\frontend\config.js.example ---
const CONFIG = {
  auth0Domain: "<AUTH0_DOMAIN>",
  auth0ClientId: "<AUTH0_CLIENT_ID>",
  auth0Audience: "<AUTH0_AUDIENCE>",
  apiUrl: "http://localhost:3000",
};


--- File: my-homepage\frontend\generate-config.sh ---
#!/bin/bash
# Generates frontend/config.js from environment variables.
#
# Usage (local dev):
#   source backend/.env     # or export the vars manually
#   export AUTH0_DOMAIN="dev-gtdi5x5p0nmticqd.us.auth0.com"
#   export AUTH0_CLIENT_ID="<your-client-id>"
#   export AUTH0_AUDIENCE="https://homepage.api.yourdomain.com"
#   export API_URL="https://homepage.api.yourdomain.com"
#   bash frontend/generate-config.sh
#
# In the CI/CD pipeline, these variables should be set from Terraform outputs
# or Azure App Configuration before this script runs.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

: "${AUTH0_DOMAIN:?ERROR: AUTH0_DOMAIN is not set}"
: "${AUTH0_CLIENT_ID:?ERROR: AUTH0_CLIENT_ID is not set}"
: "${AUTH0_AUDIENCE:?ERROR: AUTH0_AUDIENCE is not set}"
: "${API_URL:?ERROR: API_URL is not set}"

cat <<EOF > "$SCRIPT_DIR/config.js"
export const CONFIG = {
  auth0Domain: "${AUTH0_DOMAIN}",
  auth0ClientId: "${AUTH0_CLIENT_ID}",
  auth0Audience: "${AUTH0_AUDIENCE}",
  apiUrl: "${API_URL}",
};
EOF

echo "Successfully generated $SCRIPT_DIR/config.js"


--- File: my-homepage\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Login screen -->
  <div id="login-screen">
    <div class="login-box">
      <h1>Home</h1>
      <button id="login-btn">Log In</button>
    </div>
  </div>

  <!-- Loading state -->
  <div id="loading" class="hidden">Loading…</div>

  <!-- Main app (hidden until authenticated) -->
  <div id="app" class="hidden">
    <div id="toolbar">
      <button id="expand-all">Expand All</button>
      <button id="collapse-all">Collapse All</button>
      <div id="user-info">
        <span id="user-email"></span>
        <button id="logout-btn">Log Out</button>
      </div>
    </div>
    <div id="tree"></div>
  </div>

  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>

  <script type="module" src="script.js"></script>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js");
    }
  </script>
</body>
</html>


--- File: my-homepage\frontend\script.js ---
import { CONFIG } from './config.js';
import { initAuth, login, logout, getToken, isAuthenticated, getUser } from './auth.js';

// ── DOM references ──────────────────────────────────────────────
const loginScreen = document.getElementById("login-screen");
const loadingEl = document.getElementById("loading");
const appEl = document.getElementById("app");
const tree = document.getElementById("tree");

const CACHE_KEY = "cached_bookmarks";

// ── App entry point ─────────────────────────────────────────────

(async function main() {
  const cached = loadCachedBookmarks();

  // If we have cached data, paint immediately — no waiting for Auth0.
  if (cached) {
    loginScreen.classList.add("hidden");
    loadingEl.classList.add("hidden");
    appEl.classList.remove("hidden");
    renderBookmarks(cached);
  } else {
    // No cache — show loading while Auth0 initializes
    loginScreen.classList.add("hidden");
    loadingEl.classList.remove("hidden");
  }

  // Auth0 init happens in the background while cached UI is already visible.
  await initAuth();

  if (await isAuthenticated()) {
    await showApp(cached);
  } else if (cached) {
    // Had stale cache but session expired — fall back to login
    showLogin();
  } else {
    showLogin();
  }
})();

// ── Auth flows ──────────────────────────────────────────────────

function showLogin() {
  loadingEl.classList.add("hidden");
  appEl.classList.add("hidden");
  loginScreen.classList.remove("hidden");
}

async function showApp(alreadyRenderedCache) {
  loadingEl.classList.add("hidden");
  loginScreen.classList.add("hidden");
  appEl.classList.remove("hidden");

  // Show user email
  const user = await getUser();
  document.getElementById("user-email").textContent = user.email || user.name || "";

  // Fetch fresh bookmarks from API (background revalidation)
  const fresh = await fetchBookmarks();

  // Only re-render if the data actually changed (or if we had no cache)
  if (!alreadyRenderedCache || !bookmarksEqual(alreadyRenderedCache, fresh)) {
    saveCachedBookmarks(fresh);
    renderBookmarks(fresh);
  }
}

// ── localStorage helpers ────────────────────────────────────────

function loadCachedBookmarks() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

function saveCachedBookmarks(bookmarks) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(bookmarks));
  } catch {
    // Storage full or unavailable — non-critical
  }
}

function bookmarksEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

// ── API ─────────────────────────────────────────────────────────

async function fetchBookmarks() {
  try {
    const token = await getToken();
    const res = await fetch(`${CONFIG.apiUrl}/api/bookmarks`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error(`API error: ${res.status}`);

    const data = await res.json();
    return data.bookmarks || [];
  } catch (err) {
    console.error("Failed to fetch bookmarks:", err);
    // On network failure, return whatever we have cached
    return loadCachedBookmarks() || [];
  }
}

// ── Rendering ───────────────────────────────────────────────────

function renderBookmarks(bookmarks) {
  tree.innerHTML = "";

  if (bookmarks.length === 0) {
    tree.textContent = "No bookmarks yet.";
    return;
  }

  tree.style.setProperty(
    "--url-left",
    Math.ceil(calcMaxRowWidth(bookmarks, "")) + 2 + "ch"
  );
  tree.appendChild(renderList(bookmarks, ""));
}

// Calculate the max visual width of all tree rows (in ch units) so
// hover-revealed URLs can be aligned in a single consistent column.
function calcMaxRowWidth(items, prefix) {
  let max = 0;
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;
    // prefix+connector chars + toggle/spacer (1ch + 0.6ch gap) + name + arrow if link
    const width = (prefix + connector).length + 1.6 + item.name.length + (item.url ? 1.15 : 0);
    if (width > max) max = width;
    if (hasChildren) {
      const childMax = calcMaxRowWidth(item.children, childPrefix);
      if (childMax > max) max = childMax;
    }
  });
  return max;
}

// Build DOM for a list of sibling nodes.
// `prefix` is the inherited string of "│   " / "    " segments from ancestors.
function renderList(items, prefix) {
  const frag = document.createDocumentFragment();
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;

    // Row
    const row = document.createElement("div");
    row.className = "node";

    // Prefix (inherited tree lines)
    const pre = document.createElement("span");
    pre.className = "node-prefix";
    pre.textContent = prefix + connector;
    row.appendChild(pre);

    // Toggle button or spacer
    if (hasChildren) {
      const btn = document.createElement("button");
      btn.className = "node-toggle";
      btn.textContent = ">";
      btn.setAttribute("aria-label", "expand");
      row.appendChild(btn);
    } else {
      const spacer = document.createElement("span");
      spacer.className = "node-spacer";
      row.appendChild(spacer);
    }

    // Label
    const label = document.createElement("span");
    label.className = "node-label" + (hasChildren ? " folder" : "");
    if (item.url) {
      const a = document.createElement("a");
      a.href = item.url;
      a.textContent = item.name;
      label.appendChild(a);
      const arrow = document.createElement("span");
      arrow.className = "link-indicator";
      arrow.textContent = "↗";
      arrow.setAttribute("aria-hidden", "true");
      label.appendChild(arrow);
    } else {
      label.textContent = item.name;
    }
    row.appendChild(label);

    // URL hint shown on hover
    if (item.url) {
      const urlSpan = document.createElement("span");
      urlSpan.className = "node-url";
      urlSpan.textContent = item.url;
      row.appendChild(urlSpan);
    }

    frag.appendChild(row);

    // Children
    if (hasChildren) {
      const childrenContainer = document.createElement("div");
      childrenContainer.className = "children";
      childrenContainer.appendChild(renderList(item.children, childPrefix));
      frag.appendChild(childrenContainer);

      // Wire toggle — whole row triggers expand/collapse
      const btn = row.querySelector(".node-toggle");
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        // If click landed on a link, let it navigate instead of toggling
        if (e.target.closest("a")) return;
        const open = childrenContainer.classList.toggle("open");
        btn.classList.toggle("open", open);
        btn.textContent = open ? "v" : ">";
        btn.setAttribute("aria-label", open ? "collapse" : "expand");
      });
    } else if (item.url) {
      // Wire link — whole row navigates
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        if (e.target.tagName === "A") return; // let native <a> handle itself
        window.location.href = item.url;
      });
    }
  });
  return frag;
}

// ── Toolbar ─────────────────────────────────────────────────────

document.getElementById("expand-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.add("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.add("open");
    btn.textContent = "v";
    btn.setAttribute("aria-label", "collapse");
  });
});

document.getElementById("collapse-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.remove("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.remove("open");
    btn.textContent = ">";
    btn.setAttribute("aria-label", "expand");
  });
});

document.getElementById("login-btn").addEventListener("click", login);
document.getElementById("logout-btn").addEventListener("click", logout);


--- File: my-homepage\frontend\style.css ---
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #1e1e2e;
  color: #cdd6f4;
  font-family: "Cascadia Code", "Fira Code", "JetBrains Mono", "Consolas", monospace;
  font-size: 18px;
  padding: 32px;
  line-height: 1.6;
}

#toolbar {
  max-width: 720px;
  margin-bottom: 12px;
  display: flex;
  gap: 8px;
}

#toolbar button {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#toolbar button:hover {
  background: #45475a;
}

#tree {
  max-width: 720px;
}

/* ── Each node row ─────────────────────────────── */

.node {
  display: flex;
  align-items: baseline;
  position: relative;
}

.node.clickable {
  cursor: pointer;
}

.node.clickable:hover {
  background: #2a2a3e;
}

.node-prefix {
  white-space: pre;
  color: #585b70;
  user-select: none;
}

.node-toggle {
  background: none;
  border: none;
  color: #585b70;
  cursor: pointer;
  font-family: inherit;
  font-size: inherit;
  padding: 0;
  width: 1ch;
  margin-right: 0.6ch;
  text-align: center;
  user-select: none;
  transition: color 0.15s;
}

.node-toggle:hover {
  color: #cdd6f4;
}

.node-toggle.open {
  /* purely cosmetic class — JS swaps the character */
}

.node-spacer {
  width: 1ch;
  margin-right: 0.6ch;
  display: inline-block;
}

.node-label a {
  color: #89b4fa;
  text-decoration: none;
  transition: color 0.15s;
}

.node-label a:hover {
  color: #b4befe;
  text-decoration: underline;
}

.link-indicator {
  color: #585b70;
  font-size: 0.75em;
  margin-left: 0.4ch;
  transition: color 0.15s;
}

.node.clickable:hover .link-indicator,
.node-label a:hover + .link-indicator {
  color: #b4befe;
}

.node-label.folder {
  color: #a6e3a1;
  font-weight: bold;
}

.node-label.folder a {
  color: #a6e3a1;
}

.node-label.folder a:hover {
  color: #b4befe;
}

/* ── Hover URL hint ───────────────────────────── */

.node-url {
  display: none;
  position: absolute;
  left: var(--url-left);
  color: #585b70;
  pointer-events: none;
  white-space: nowrap;
}

.node:hover > .node-url {
  display: inline;
}

/* ── Children container ────────────────────────── */

.children {
  display: none;
}

.children.open {
  display: block;
}

/* ── Hidden utility ──────────────────────────── */

.hidden {
  display: none !important;
}

/* ── Loading state ───────────────────────────── */

#loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
  color: #585b70;
  font-size: 1.2em;
}

/* ── Login screen ────────────────────────────── */

#login-screen {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
}

.login-box {
  text-align: center;
}

.login-box h1 {
  color: #cdd6f4;
  font-size: 2em;
  margin-bottom: 24px;
}

#login-btn {
  background: #89b4fa;
  color: #1e1e2e;
  border: none;
  border-radius: 4px;
  padding: 10px 32px;
  font-family: inherit;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.15s;
}

#login-btn:hover {
  background: #b4befe;
}

/* ── User info / logout ──────────────────────── */

#user-info {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

#user-email {
  color: #585b70;
  font-size: 0.8em;
}

#logout-btn {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#logout-btn:hover {
  background: #45475a;
}

/* ── Mobile responsive ───────────────────────── */

@media (max-width: 600px) {
  body {
    padding: 12px;
    font-size: 15px;
  }

  #toolbar {
    flex-wrap: wrap;
  }

  #user-info {
    width: 100%;
    margin-left: 0;
    justify-content: flex-end;
  }

  #tree {
    max-width: 100%;
    overflow-x: auto;
  }

  .node-url {
    display: none !important;
  }
}


--- File: my-homepage\frontend\sw.js ---
const CACHE_NAME = "app-shell-v1";
const SHELL_ASSETS = [
  "/",
  "/index.html",
  "/style.css",
  "/script.js",
  "/auth.js",
  "/config.js",
];

// ── Install: pre-cache the app shell ────────────────────────────
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(SHELL_ASSETS))
  );
  self.skipWaiting();
});

// ── Activate: clean up old caches ───────────────────────────────
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys
          .filter((key) => key !== CACHE_NAME)
          .map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

// ── Fetch: cache-first for same-origin, network-only for API/CDN ─
self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);

  // Skip non-GET requests
  if (event.request.method !== "GET") return;

  // Skip API calls — let the app handle those with its own caching
  if (url.pathname.startsWith("/api/")) return;

  // Skip cross-origin requests (Auth0 CDN, etc.)
  if (url.origin !== self.location.origin) return;

  event.respondWith(
    caches.match(event.request).then((cached) => {
      if (cached) return cached;

      // Handle root navigation explicitly
      if (event.request.mode === 'navigate') {
        return caches.match('/index.html').then(html => html || fetch(event.request));
      }

      return fetch(event.request).then((response) => {
        // Cache new same-origin assets on the fly
        const clone = response.clone();
        caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
        return response;
      });
    })
  );
});


--- File: my-homepage\frontend\workspace_context.txt ---
=============================================================
WORKSPACE FOLDER: my-homepage
=============================================================

--- File: my-homepage\.gitignore ---
frontend/config.js
frontend/bookmarks.js
backend/.env
backend/node_modules/


--- File: my-homepage\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: my-homepage\.github\workflows\container-app-build.yml ---
# Test 6
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
    secrets: inherit

--- File: my-homepage\.github\workflows\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ inputs.commit_sha }}
    secrets: inherit

--- File: my-homepage\.github\workflows\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: my-homepage\.github\workflows\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: my-homepage\.github\workflows\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

--- File: my-homepage\backend\.env ---
AZURE_APP_CONFIG_ENDPOINT=https://infra-appconfig.azconfig.io
APP_CONFIG_PREFIX=homepage
AZURE_TENANT_ID="2236b5e4-81d2-4d82-bde5-17b1037999ea"


--- File: my-homepage\backend\package.json ---
{
  "name": "my-homepage-api",
  "version": "1.0.0",
  "type": "module",
  "description": "My Homepage Backend API with Azure Cosmos DB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "license": "MIT",
  "dependencies": {
    "@azure/app-configuration": "^1.11.0",
    "@azure/cosmos": "^4.0.0",
    "@azure/identity": "^4.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2",
    "express-oauth2-jwt-bearer": "^1.7.4",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}


--- File: my-homepage\backend\server.js ---
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import cors from 'cors';
import { CosmosClient } from '@azure/cosmos';
import { DefaultAzureCredential } from '@azure/identity';
import { createRequireAuth } from './middleware/auth.js';
import { fetchAppConfig } from './startup/appConfig.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware that does NOT depend on async config — safe to register now
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

async function startServer() {
  // Step 1: Fetch AUTH0_DOMAIN and AUTH0_AUDIENCE from Azure App Configuration.
  const { auth0Domain, auth0Audience, cosmosDbEndpoint } = await fetchAppConfig();

  // Step 2: Build the Auth0 JWT middleware now that we have the values.
  const requireAuth = createRequireAuth({ auth0Domain, auth0Audience });

  // Step 3: Initialize Cosmos DB client.
  const DATABASE_NAME = process.env.COSMOS_DB_DATABASE_NAME || 'HomepageDB';
  const CONTAINER_NAME = process.env.COSMOS_DB_CONTAINER_NAME || 'userdata';

  let container;
  try {
    const credential = new DefaultAzureCredential();
    const client = new CosmosClient({
      endpoint: cosmosDbEndpoint,
      aadCredentials: credential
    });

    const database = client.database(DATABASE_NAME);
    container = database.container(CONTAINER_NAME);
    console.log('Connected to Cosmos DB using Azure Identity');
  } catch (error) {
    console.error('Failed to connect to Cosmos DB:', error);
    process.exit(1);
  }

  // Step 4: Register all routes.

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: DATABASE_NAME,
      container: CONTAINER_NAME
    });
  });

  // Database initialization endpoint
  app.post('/api/admin/init-database', requireAuth, async (req, res) => {
    try {
      const credential = new DefaultAzureCredential();
      const client = new CosmosClient({
        endpoint: cosmosDbEndpoint,
        aadCredentials: credential
      });

      // Create database if it doesn't exist
      const { database } = await client.databases.createIfNotExists({
        id: DATABASE_NAME
      });

      // Create container if it doesn't exist
      const { container: newContainer } = await database.containers.createIfNotExists({
        id: CONTAINER_NAME,
        partitionKey: {
          paths: ['/userId']
        }
      });

      // Optionally seed bookmarks for the current user
      const userId = req.auth.payload.sub;
      let seeded = false;

      if (req.body.bookmarks) {
        const bookmarksDoc = {
          id: `bookmarks_${userId}`,
          userId,
          type: 'bookmarks',
          bookmarks: req.body.bookmarks,
          updatedAt: new Date().toISOString()
        };
        await newContainer.items.upsert(bookmarksDoc);
        seeded = true;
      }

      res.json({
        success: true,
        message: 'Database initialized successfully',
        database: DATABASE_NAME,
        container: CONTAINER_NAME,
        seeded
      });
    } catch (error) {
      console.error('Error initializing database:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize database',
        message: error.message
      });
    }
  });

  // Get bookmarks for the authenticated user
  app.get('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;

      const querySpec = {
        query: 'SELECT * FROM c WHERE c.type = @type AND c.userId = @userId',
        parameters: [
          { name: '@type', value: 'bookmarks' },
          { name: '@userId', value: userId }
        ]
      };

      const { resources } = await container.items.query(querySpec).fetchAll();

      if (resources.length === 0) {
        return res.json({ bookmarks: [] });
      }

      res.json({ bookmarks: resources[0].bookmarks });
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ error: 'Failed to fetch bookmarks', message: error.message });
    }
  });

  // Save/update bookmarks for the authenticated user
  app.put('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;
      const { bookmarks } = req.body;

      if (!Array.isArray(bookmarks)) {
        return res.status(400).json({ error: 'Request body must contain a bookmarks array' });
      }

      const bookmarksDoc = {
        id: `bookmarks_${userId}`,
        userId,
        type: 'bookmarks',
        bookmarks,
        updatedAt: new Date().toISOString()
      };

      const { resource } = await container.items.upsert(bookmarksDoc);

      res.json({ bookmarks: resource.bookmarks, updatedAt: resource.updatedAt });
    } catch (error) {
      console.error('Error saving bookmarks:', error);
      res.status(500).json({ error: 'Failed to save bookmarks', message: error.message });
    }
  });

  // In production, serve frontend static files
  if (process.env.NODE_ENV === 'production') {
    app.use(express.static('../frontend'));
  }

  // 404 handler
  app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
  });

  // Error handler
  app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error', message: err.message });
  });

  // Step 5: Start listening only after all setup is complete.
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`Database: ${DATABASE_NAME}`);
    console.log(`Container: ${CONTAINER_NAME}`);
    console.log(`Auth0 domain: ${auth0Domain}`);
    console.log(`Health check: http://localhost:${PORT}/health`);
  });
}

startServer().catch((error) => {
  console.error('Fatal startup error:', error);
  process.exit(1);
});

export default app;


--- File: my-homepage\backend\middleware\auth.js ---
import { auth } from 'express-oauth2-jwt-bearer';

/**
 * Creates the Auth0 JWT validation middleware.
 *
 * Must be called after Azure App Configuration values are fetched,
 * because auth() is a synchronous factory that reads its arguments immediately.
 *
 * @param {{ auth0Domain: string, auth0Audience: string }} config
 * @returns {import('express').RequestHandler}
 */
export function createRequireAuth({ auth0Domain, auth0Audience }) {
  return auth({
    audience: auth0Audience,
    issuerBaseURL: `https://${auth0Domain}/`,
    tokenSigningAlg: 'RS256',
  });
}


--- File: my-homepage\backend\startup\appConfig.js ---
import { AppConfigurationClient } from '@azure/app-configuration';
import { DefaultAzureCredential } from '@azure/identity';

/**
 * Fetches application configuration from Azure App Configuration.
 *
 * AZURE_APP_CONFIG_ENDPOINT is infrastructure config (not a secret) and
 * is injected as a plain environment variable on the Container App.
 *
 * @returns {Promise<{ auth0Domain: string, auth0Audience: string, cosmosDbEndpoint: string }>}
 */
export async function fetchAppConfig() {
  const endpoint = process.env.AZURE_APP_CONFIG_ENDPOINT;

  if (!endpoint) {
    throw new Error(
      'AZURE_APP_CONFIG_ENDPOINT environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const prefix = process.env.APP_CONFIG_PREFIX;

  if (!prefix) {
    throw new Error(
      'APP_CONFIG_PREFIX environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const credential = new DefaultAzureCredential();
  const client = new AppConfigurationClient(endpoint, credential);

  const [domainSetting, audienceSetting, cosmosEndpointSetting] = await Promise.all([
    client.getConfigurationSetting({ key: 'AUTH0_DOMAIN' }),
    client.getConfigurationSetting({ key: `${prefix}/AUTH0_AUDIENCE` }),
    client.getConfigurationSetting({ key: 'cosmos_db_endpoint' }),
  ]);

  const auth0Domain = domainSetting.value;
  const auth0Audience = audienceSetting.value;
  const cosmosDbEndpoint = cosmosEndpointSetting.value;

  if (!auth0Domain || !auth0Audience || !cosmosDbEndpoint) {
    throw new Error(
      `Azure App Configuration is missing required keys. ` +
      `Ensure AUTH0_DOMAIN, ${prefix}/AUTH0_AUDIENCE, and cosmos_db_endpoint are set in the store.`
    );
  }

  console.log('[appConfig] Application config fetched from Azure App Configuration');
  return { auth0Domain, auth0Audience, cosmosDbEndpoint };
}


--- File: my-homepage\frontend\auth.js ---
/* global auth0, CONFIG */

let auth0Client = null;

async function initAuth() {
  auth0Client = await auth0.createAuth0Client({
    domain: CONFIG.auth0Domain,
    clientId: CONFIG.auth0ClientId,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: CONFIG.auth0Audience,
    },
  });

  // Handle redirect callback
  const query = window.location.search;
  if (query.includes("code=") && query.includes("state=")) {
    await auth0Client.handleRedirectCallback();
    window.history.replaceState({}, document.title, window.location.pathname);
  }

  return auth0Client;
}

async function login() {
  await auth0Client.loginWithRedirect();
}

async function logout() {
  await auth0Client.logout({
    logoutParams: { returnTo: window.location.origin },
  });
}

async function getToken() {
  return auth0Client.getTokenSilently({
    authorizationParams: { audience: CONFIG.auth0Audience },
  });
}

async function isAuthenticated() {
  return auth0Client.isAuthenticated();
}

async function getUser() {
  return auth0Client.getUser();
}


--- File: my-homepage\frontend\bookmarks.js ---
const bookmarks = [
  {
    name: "Home",
    children: [
      {
        name: "Voice",
        url: "http://voice.google.com/u/0/messages"
      },
      {
        name: "Chess",
        url: "https://www.chess.com/"
      },
      {
        name: "Reddit",
        url: "https://www.reddit.com/"
      },
      {
        name: "YouTube",
        url: "https://www.youtube.com/"
      },
      {
        name: "Google",
        url: "http://google.com/"
      },
      {
        name: "Workout",
        url: "https://docs.google.com/spreadsheets/d/1qdizKHXq5e465dt5ChbcKsGTYG6QmjON/edit?gid=1734961154#gid=1734961154"
      },
      {
        name: "Google Calendar",
        url: "https://calendar.google.com/calendar/u/0/r"
      },
      {
        name: "Amazon",
        url: "https://www.amazon.com/"
      },
      {
        name: "Nelsonhub",
        url: "http://192.168.50.131/"
      }
    ]
  },
  {
    name: "Projects",
    children: [
      {
        name: "Spacelift",
        url: "https://nelsong6.app.spacelift.io/stack/new-pokemon-appeared/run/01K4JKE4EGWVCRKAB6BZ6RXHJB"
      },
      {
        name: "Azure",
        url: "https://portal.azure.com/#home"
      },
      {
        name: "New Pokemon Appears",
        url: "https://github.com/nelsong6/new-pokemon-appeared/milestone/4"
      }
    ]
  },
  {
    name: "Bills",
    children: [
      {
        name: "Ameriprise",
        url: "https://www.ameriprise.com/client-login"
      },
      {
        name: "Chase",
        url: "https://www.chase.com/"
      },
      {
        name: "Loancare",
        url: "https://myloancare.com/web/home"
      },
      {
        name: "Water Delivery",
        url: "https://drink.water.com/"
      },
      {
        name: "Haircut",
        url: "https://www.vagaro.com/roots66salons"
      }
    ]
  },
  {
    name: "Dev",
    children: [
      {
        name: "Auth0",
        url: "http://auth0.com/"
      },
      {
        name: "Github",
        url: "https://github.com/nelsong6"
      },
      {
        name: "Spacelift",
        url: "https://nelsong6.app.us.spacelift.io/dashboard"
      },
      {
        name: "Claude",
        url: "https://platform.claude.com/"
      }
    ]
  }
];

--- File: my-homepage\frontend\bookmarks.js.example ---
const bookmarks = [
  {
    name: "Social",
    children: [
      { name: "Twitter", url: "https://twitter.com" },
      { name: "Reddit", url: "https://reddit.com" },
      { name: "YouTube", url: "https://youtube.com" },
    ],
  },
  {
    name: "Dev",
    url: "https://github.com",
    children: [
      { name: "GitHub", url: "https://github.com" },
      { name: "Stack Overflow", url: "https://stackoverflow.com" },
      { name: "MDN Web Docs", url: "https://developer.mozilla.org" },
    ],
  },
  {
    name: "News",
    children: [
      { name: "Hacker News", url: "https://news.ycombinator.com" },
      { name: "Lobsters", url: "https://lobste.rs" },
    ],
  },
  {
    name: "Tools",
    children: [
      {
        name: "Search",
        children: [
          { name: "Google", url: "https://google.com" },
          { name: "DuckDuckGo", url: "https://duckduckgo.com" },
        ],
      },
      { name: "Email", url: "https://mail.google.com" },
    ],
  },
];


--- File: my-homepage\frontend\config.js.example ---
const CONFIG = {
  auth0Domain: "<AUTH0_DOMAIN>",
  auth0ClientId: "<AUTH0_CLIENT_ID>",
  auth0Audience: "<AUTH0_AUDIENCE>",
  apiUrl: "http://localhost:3000",
};


--- File: my-homepage\frontend\generate-config.sh ---
#!/bin/bash
# Generates frontend/config.js from environment variables.
#
# Usage (local dev):
#   source backend/.env     # or export the vars manually
#   export AUTH0_DOMAIN="dev-gtdi5x5p0nmticqd.us.auth0.com"
#   export AUTH0_CLIENT_ID="<your-client-id>"
#   export AUTH0_AUDIENCE="https://homepage.api.yourdomain.com"
#   export API_URL="https://homepage.api.yourdomain.com"
#   bash frontend/generate-config.sh
#
# In the CI/CD pipeline, these variables should be set from Terraform outputs
# or Azure App Configuration before this script runs.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

: "${AUTH0_DOMAIN:?ERROR: AUTH0_DOMAIN is not set}"
: "${AUTH0_CLIENT_ID:?ERROR: AUTH0_CLIENT_ID is not set}"
: "${AUTH0_AUDIENCE:?ERROR: AUTH0_AUDIENCE is not set}"
: "${API_URL:?ERROR: API_URL is not set}"

cat <<EOF > "$SCRIPT_DIR/config.js"
const CONFIG = {
  auth0Domain: "${AUTH0_DOMAIN}",
  auth0ClientId: "${AUTH0_CLIENT_ID}",
  auth0Audience: "${AUTH0_AUDIENCE}",
  apiUrl: "${API_URL}",
};
EOF

echo "Successfully generated $SCRIPT_DIR/config.js"


--- File: my-homepage\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Login screen -->
  <div id="login-screen">
    <div class="login-box">
      <h1>Home</h1>
      <button id="login-btn">Log In</button>
    </div>
  </div>

  <!-- Loading state -->
  <div id="loading" class="hidden">Loading…</div>

  <!-- Main app (hidden until authenticated) -->
  <div id="app" class="hidden">
    <div id="toolbar">
      <button id="expand-all">Expand All</button>
      <button id="collapse-all">Collapse All</button>
      <div id="user-info">
        <span id="user-email"></span>
        <button id="logout-btn">Log Out</button>
      </div>
    </div>
    <div id="tree"></div>
  </div>

  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
  <script src="config.js"></script>
  <script src="auth.js"></script>
  <script src="script.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js");
    }
  </script>
</body>
</html>


--- File: my-homepage\frontend\script.js ---
/* global CONFIG, initAuth, login, logout, getToken, isAuthenticated, getUser */

// ── DOM references ──────────────────────────────────────────────
const loginScreen = document.getElementById("login-screen");
const loadingEl = document.getElementById("loading");
const appEl = document.getElementById("app");
const tree = document.getElementById("tree");

const CACHE_KEY = "cached_bookmarks";

// ── App entry point ─────────────────────────────────────────────

(async function main() {
  const cached = loadCachedBookmarks();

  // If we have cached data, paint immediately — no waiting for Auth0.
  if (cached) {
    loginScreen.classList.add("hidden");
    loadingEl.classList.add("hidden");
    appEl.classList.remove("hidden");
    renderBookmarks(cached);
  } else {
    // No cache — show loading while Auth0 initializes
    loginScreen.classList.add("hidden");
    loadingEl.classList.remove("hidden");
  }

  // Auth0 init happens in the background while cached UI is already visible.
  await initAuth();

  if (await isAuthenticated()) {
    await showApp(cached);
  } else if (cached) {
    // Had stale cache but session expired — fall back to login
    showLogin();
  } else {
    showLogin();
  }
})();

// ── Auth flows ──────────────────────────────────────────────────

function showLogin() {
  loadingEl.classList.add("hidden");
  appEl.classList.add("hidden");
  loginScreen.classList.remove("hidden");
}

async function showApp(alreadyRenderedCache) {
  loadingEl.classList.add("hidden");
  loginScreen.classList.add("hidden");
  appEl.classList.remove("hidden");

  // Show user email
  const user = await getUser();
  document.getElementById("user-email").textContent = user.email || user.name || "";

  // Fetch fresh bookmarks from API (background revalidation)
  const fresh = await fetchBookmarks();

  // Only re-render if the data actually changed (or if we had no cache)
  if (!alreadyRenderedCache || !bookmarksEqual(alreadyRenderedCache, fresh)) {
    saveCachedBookmarks(fresh);
    renderBookmarks(fresh);
  }
}

// ── localStorage helpers ────────────────────────────────────────

function loadCachedBookmarks() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

function saveCachedBookmarks(bookmarks) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(bookmarks));
  } catch {
    // Storage full or unavailable — non-critical
  }
}

function bookmarksEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

// ── API ─────────────────────────────────────────────────────────

async function fetchBookmarks() {
  try {
    const token = await getToken();
    const res = await fetch(`${CONFIG.apiUrl}/api/bookmarks`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error(`API error: ${res.status}`);

    const data = await res.json();
    return data.bookmarks || [];
  } catch (err) {
    console.error("Failed to fetch bookmarks:", err);
    // On network failure, return whatever we have cached
    return loadCachedBookmarks() || [];
  }
}

// ── Rendering ───────────────────────────────────────────────────

function renderBookmarks(bookmarks) {
  tree.innerHTML = "";

  if (bookmarks.length === 0) {
    tree.textContent = "No bookmarks yet.";
    return;
  }

  tree.style.setProperty(
    "--url-left",
    Math.ceil(calcMaxRowWidth(bookmarks, "")) + 2 + "ch"
  );
  tree.appendChild(renderList(bookmarks, ""));
}

// Calculate the max visual width of all tree rows (in ch units) so
// hover-revealed URLs can be aligned in a single consistent column.
function calcMaxRowWidth(items, prefix) {
  let max = 0;
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;
    // prefix+connector chars + toggle/spacer (1ch + 0.6ch gap) + name + arrow if link
    const width = (prefix + connector).length + 1.6 + item.name.length + (item.url ? 1.15 : 0);
    if (width > max) max = width;
    if (hasChildren) {
      const childMax = calcMaxRowWidth(item.children, childPrefix);
      if (childMax > max) max = childMax;
    }
  });
  return max;
}

// Build DOM for a list of sibling nodes.
// `prefix` is the inherited string of "│   " / "    " segments from ancestors.
function renderList(items, prefix) {
  const frag = document.createDocumentFragment();
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;

    // Row
    const row = document.createElement("div");
    row.className = "node";

    // Prefix (inherited tree lines)
    const pre = document.createElement("span");
    pre.className = "node-prefix";
    pre.textContent = prefix + connector;
    row.appendChild(pre);

    // Toggle button or spacer
    if (hasChildren) {
      const btn = document.createElement("button");
      btn.className = "node-toggle";
      btn.textContent = ">";
      btn.setAttribute("aria-label", "expand");
      row.appendChild(btn);
    } else {
      const spacer = document.createElement("span");
      spacer.className = "node-spacer";
      row.appendChild(spacer);
    }

    // Label
    const label = document.createElement("span");
    label.className = "node-label" + (hasChildren ? " folder" : "");
    if (item.url) {
      const a = document.createElement("a");
      a.href = item.url;
      a.textContent = item.name;
      label.appendChild(a);
      const arrow = document.createElement("span");
      arrow.className = "link-indicator";
      arrow.textContent = "↗";
      arrow.setAttribute("aria-hidden", "true");
      label.appendChild(arrow);
    } else {
      label.textContent = item.name;
    }
    row.appendChild(label);

    // URL hint shown on hover
    if (item.url) {
      const urlSpan = document.createElement("span");
      urlSpan.className = "node-url";
      urlSpan.textContent = item.url;
      row.appendChild(urlSpan);
    }

    frag.appendChild(row);

    // Children
    if (hasChildren) {
      const childrenContainer = document.createElement("div");
      childrenContainer.className = "children";
      childrenContainer.appendChild(renderList(item.children, childPrefix));
      frag.appendChild(childrenContainer);

      // Wire toggle — whole row triggers expand/collapse
      const btn = row.querySelector(".node-toggle");
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        // If click landed on a link, let it navigate instead of toggling
        if (e.target.closest("a")) return;
        const open = childrenContainer.classList.toggle("open");
        btn.classList.toggle("open", open);
        btn.textContent = open ? "v" : ">";
        btn.setAttribute("aria-label", open ? "collapse" : "expand");
      });
    } else if (item.url) {
      // Wire link — whole row navigates
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        if (e.target.tagName === "A") return; // let native <a> handle itself
        window.location.href = item.url;
      });
    }
  });
  return frag;
}

// ── Toolbar ─────────────────────────────────────────────────────

document.getElementById("expand-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.add("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.add("open");
    btn.textContent = "v";
    btn.setAttribute("aria-label", "collapse");
  });
});

document.getElementById("collapse-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.remove("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.remove("open");
    btn.textContent = ">";
    btn.setAttribute("aria-label", "expand");
  });
});

document.getElementById("login-btn").addEventListener("click", login);
document.getElementById("logout-btn").addEventListener("click", logout);


--- File: my-homepage\frontend\style.css ---
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #1e1e2e;
  color: #cdd6f4;
  font-family: "Cascadia Code", "Fira Code", "JetBrains Mono", "Consolas", monospace;
  font-size: 18px;
  padding: 32px;
  line-height: 1.6;
}

#toolbar {
  max-width: 720px;
  margin-bottom: 12px;
  display: flex;
  gap: 8px;
}

#toolbar button {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#toolbar button:hover {
  background: #45475a;
}

#tree {
  max-width: 720px;
}

/* ── Each node row ─────────────────────────────── */

.node {
  display: flex;
  align-items: baseline;
  position: relative;
}

.node.clickable {
  cursor: pointer;
}

.node.clickable:hover {
  background: #2a2a3e;
}

.node-prefix {
  white-space: pre;
  color: #585b70;
  user-select: none;
}

.node-toggle {
  background: none;
  border: none;
  color: #585b70;
  cursor: pointer;
  font-family: inherit;
  font-size: inherit;
  padding: 0;
  width: 1ch;
  margin-right: 0.6ch;
  text-align: center;
  user-select: none;
  transition: color 0.15s;
}

.node-toggle:hover {
  color: #cdd6f4;
}

.node-toggle.open {
  /* purely cosmetic class — JS swaps the character */
}

.node-spacer {
  width: 1ch;
  margin-right: 0.6ch;
  display: inline-block;
}

.node-label a {
  color: #89b4fa;
  text-decoration: none;
  transition: color 0.15s;
}

.node-label a:hover {
  color: #b4befe;
  text-decoration: underline;
}

.link-indicator {
  color: #585b70;
  font-size: 0.75em;
  margin-left: 0.4ch;
  transition: color 0.15s;
}

.node.clickable:hover .link-indicator,
.node-label a:hover + .link-indicator {
  color: #b4befe;
}

.node-label.folder {
  color: #a6e3a1;
  font-weight: bold;
}

.node-label.folder a {
  color: #a6e3a1;
}

.node-label.folder a:hover {
  color: #b4befe;
}

/* ── Hover URL hint ───────────────────────────── */

.node-url {
  display: none;
  position: absolute;
  left: var(--url-left);
  color: #585b70;
  pointer-events: none;
  white-space: nowrap;
}

.node:hover > .node-url {
  display: inline;
}

/* ── Children container ────────────────────────── */

.children {
  display: none;
}

.children.open {
  display: block;
}

/* ── Hidden utility ──────────────────────────── */

.hidden {
  display: none !important;
}

/* ── Loading state ───────────────────────────── */

#loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
  color: #585b70;
  font-size: 1.2em;
}

/* ── Login screen ────────────────────────────── */

#login-screen {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
}

.login-box {
  text-align: center;
}

.login-box h1 {
  color: #cdd6f4;
  font-size: 2em;
  margin-bottom: 24px;
}

#login-btn {
  background: #89b4fa;
  color: #1e1e2e;
  border: none;
  border-radius: 4px;
  padding: 10px 32px;
  font-family: inherit;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.15s;
}

#login-btn:hover {
  background: #b4befe;
}

/* ── User info / logout ──────────────────────── */

#user-info {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

#user-email {
  color: #585b70;
  font-size: 0.8em;
}

#logout-btn {
  background: #313244;
  color: #cdd6f4;
  border: 1px solid #45475a;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: background 0.15s;
}

#logout-btn:hover {
  background: #45475a;
}

/* ── Mobile responsive ───────────────────────── */

@media (max-width: 600px) {
  body {
    padding: 12px;
    font-size: 15px;
  }

  #toolbar {
    flex-wrap: wrap;
  }

  #user-info {
    width: 100%;
    margin-left: 0;
    justify-content: flex-end;
  }

  #tree {
    max-width: 100%;
    overflow-x: auto;
  }

  .node-url {
    display: none !important;
  }
}


--- File: my-homepage\frontend\sw.js ---
const CACHE_NAME = "app-shell-v1";
const SHELL_ASSETS = [
  "/",
  "/index.html",
  "/style.css",
  "/script.js",
  "/auth.js",
  "/config.js",
];

// ── Install: pre-cache the app shell ────────────────────────────
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(SHELL_ASSETS))
  );
  self.skipWaiting();
});

// ── Activate: clean up old caches ───────────────────────────────
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys
          .filter((key) => key !== CACHE_NAME)
          .map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

// ── Fetch: cache-first for same-origin, network-only for API/CDN ─
self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);

  // Skip non-GET requests
  if (event.request.method !== "GET") return;

  // Skip API calls — let the app handle those with its own caching
  if (url.pathname.startsWith("/api/")) return;

  // Skip cross-origin requests (Auth0 CDN, etc.)
  if (url.origin !== self.location.origin) return;

  event.respondWith(
    caches.match(event.request).then(
      (cached) =>
        cached ||
        fetch(event.request).then((response) => {
          // Cache new same-origin assets on the fly
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
          return response;
        })
    )
  );
});


--- File: my-homepage\frontend\workspace_context.txt ---
=============================================================
WORKSPACE FOLDER: my-homepage
=============================================================

--- File: my-homepage\.gitignore ---
frontend/config.js
frontend/bookmarks.js
backend/.env
backend/node_modules/


--- File: my-homepage\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: my-homepage\.github\workflows\container-app-build.yml ---
# Test 6
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
    secrets: inherit

--- File: my-homepage\.github\workflows\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ inputs.commit_sha }}
    secrets: inherit

--- File: my-homepage\.github\workflows\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: my-homepage\.github\workflows\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: my-homepage\.github\workflows\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

--- File: my-homepage\backend\.env ---
AZURE_APP_CONFIG_ENDPOINT=https://infra-appconfig.azconfig.io
APP_CONFIG_PREFIX=homepage
AZURE_TENANT_ID="2236b5e4-81d2-4d82-bde5-17b1037999ea"


--- File: my-homepage\backend\package.json ---
{
  "name": "my-homepage-api",
  "version": "1.0.0",
  "type": "module",
  "description": "My Homepage Backend API with Azure Cosmos DB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "license": "MIT",
  "dependencies": {
    "@azure/app-configuration": "^1.11.0",
    "@azure/cosmos": "^4.0.0",
    "@azure/identity": "^4.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2",
    "express-oauth2-jwt-bearer": "^1.7.4",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}


--- File: my-homepage\backend\server.js ---
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import cors from 'cors';
import { CosmosClient } from '@azure/cosmos';
import { DefaultAzureCredential } from '@azure/identity';
import { createRequireAuth } from './middleware/auth.js';
import { fetchAppConfig } from './startup/appConfig.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware that does NOT depend on async config — safe to register now
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

async function startServer() {
  // Step 1: Fetch AUTH0_DOMAIN and AUTH0_AUDIENCE from Azure App Configuration.
  const { auth0Domain, auth0Audience, cosmosDbEndpoint } = await fetchAppConfig();

  // Step 2: Build the Auth0 JWT middleware now that we have the values.
  const requireAuth = createRequireAuth({ auth0Domain, auth0Audience });

  // Step 3: Initialize Cosmos DB client.
  const DATABASE_NAME = process.env.COSMOS_DB_DATABASE_NAME || 'HomepageDB';
  const CONTAINER_NAME = process.env.COSMOS_DB_CONTAINER_NAME || 'userdata';

  let container;
  try {
    const credential = new DefaultAzureCredential();
    const client = new CosmosClient({
      endpoint: cosmosDbEndpoint,
      aadCredentials: credential
    });

    const database = client.database(DATABASE_NAME);
    container = database.container(CONTAINER_NAME);
    console.log('Connected to Cosmos DB using Azure Identity');
  } catch (error) {
    console.error('Failed to connect to Cosmos DB:', error);
    process.exit(1);
  }

  // Step 4: Register all routes.

  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: DATABASE_NAME,
      container: CONTAINER_NAME
    });
  });

  // Database initialization endpoint
  app.post('/api/admin/init-database', requireAuth, async (req, res) => {
    try {
      const credential = new DefaultAzureCredential();
      const client = new CosmosClient({
        endpoint: cosmosDbEndpoint,
        aadCredentials: credential
      });

      // Create database if it doesn't exist
      const { database } = await client.databases.createIfNotExists({
        id: DATABASE_NAME
      });

      // Create container if it doesn't exist
      const { container: newContainer } = await database.containers.createIfNotExists({
        id: CONTAINER_NAME,
        partitionKey: {
          paths: ['/userId']
        }
      });

      // Optionally seed bookmarks for the current user
      const userId = req.auth.payload.sub;
      let seeded = false;

      if (req.body.bookmarks) {
        const bookmarksDoc = {
          id: `bookmarks_${userId}`,
          userId,
          type: 'bookmarks',
          bookmarks: req.body.bookmarks,
          updatedAt: new Date().toISOString()
        };
        await newContainer.items.upsert(bookmarksDoc);
        seeded = true;
      }

      res.json({
        success: true,
        message: 'Database initialized successfully',
        database: DATABASE_NAME,
        container: CONTAINER_NAME,
        seeded
      });
    } catch (error) {
      console.error('Error initializing database:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize database',
        message: error.message
      });
    }
  });

  // Get bookmarks for the authenticated user
  app.get('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;

      const querySpec = {
        query: 'SELECT * FROM c WHERE c.type = @type AND c.userId = @userId',
        parameters: [
          { name: '@type', value: 'bookmarks' },
          { name: '@userId', value: userId }
        ]
      };

      const { resources } = await container.items.query(querySpec).fetchAll();

      if (resources.length === 0) {
        return res.json({ bookmarks: [] });
      }

      res.json({ bookmarks: resources[0].bookmarks });
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ error: 'Failed to fetch bookmarks', message: error.message });
    }
  });

  // Save/update bookmarks for the authenticated user
  app.put('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.auth.payload.sub;
      const { bookmarks } = req.body;

      if (!Array.isArray(bookmarks)) {
        return res.status(400).json({ error: 'Request body must contain a bookmarks array' });
      }

      const bookmarksDoc = {
        id: `bookmarks_${userId}`,
        userId,
        type: 'bookmarks',
        bookmarks,
        updatedAt: new Date().toISOString()
      };

      const { resource } = await container.items.upsert(bookmarksDoc);

      res.json({ bookmarks: resource.bookmarks, updatedAt: resource.updatedAt });
    } catch (error) {
      console.error('Error saving bookmarks:', error);
      res.status(500).json({ error: 'Failed to save bookmarks', message: error.message });
    }
  });

  // In production, serve frontend static files
  if (process.env.NODE_ENV === 'production') {
    app.use(express.static('../frontend'));
  }

  // 404 handler
  app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
  });

  // Error handler
  app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error', message: err.message });
  });

  // Step 5: Start listening only after all setup is complete.
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`Database: ${DATABASE_NAME}`);
    console.log(`Container: ${CONTAINER_NAME}`);
    console.log(`Auth0 domain: ${auth0Domain}`);
    console.log(`Health check: http://localhost:${PORT}/health`);
  });
}

startServer().catch((error) => {
  console.error('Fatal startup error:', error);
  process.exit(1);
});

export default app;


--- File: my-homepage\backend\middleware\auth.js ---
import { auth } from 'express-oauth2-jwt-bearer';

/**
 * Creates the Auth0 JWT validation middleware.
 *
 * Must be called after Azure App Configuration values are fetched,
 * because auth() is a synchronous factory that reads its arguments immediately.
 *
 * @param {{ auth0Domain: string, auth0Audience: string }} config
 * @returns {import('express').RequestHandler}
 */
export function createRequireAuth({ auth0Domain, auth0Audience }) {
  return auth({
    audience: auth0Audience,
    issuerBaseURL: `https://${auth0Domain}/`,
    tokenSigningAlg: 'RS256',
  });
}


--- File: my-homepage\backend\startup\appConfig.js ---
import { AppConfigurationClient } from '@azure/app-configuration';
import { DefaultAzureCredential } from '@azure/identity';

/**
 * Fetches application configuration from Azure App Configuration.
 *
 * AZURE_APP_CONFIG_ENDPOINT is infrastructure config (not a secret) and
 * is injected as a plain environment variable on the Container App.
 *
 * @returns {Promise<{ auth0Domain: string, auth0Audience: string, cosmosDbEndpoint: string }>}
 */
export async function fetchAppConfig() {
  const endpoint = process.env.AZURE_APP_CONFIG_ENDPOINT;

  if (!endpoint) {
    throw new Error(
      'AZURE_APP_CONFIG_ENDPOINT environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const prefix = process.env.APP_CONFIG_PREFIX;

  if (!prefix) {
    throw new Error(
      'APP_CONFIG_PREFIX environment variable is not set. ' +
      'This must be provided as infra config on the Container App.'
    );
  }

  const credential = new DefaultAzureCredential();
  const client = new AppConfigurationClient(endpoint, credential);

  const [domainSetting, audienceSetting, cosmosEndpointSetting] = await Promise.all([
    client.getConfigurationSetting({ key: 'AUTH0_DOMAIN' }),
    client.getConfigurationSetting({ key: `${prefix}/AUTH0_AUDIENCE` }),
    client.getConfigurationSetting({ key: 'cosmos_db_endpoint' }),
  ]);

  const auth0Domain = domainSetting.value;
  const auth0Audience = audienceSetting.value;
  const cosmosDbEndpoint = cosmosEndpointSetting.value;

  if (!auth0Domain || !auth0Audience || !cosmosDbEndpoint) {
    throw new Error(
      `Azure App Configuration is missing required keys. ` +
      `Ensure AUTH0_DOMAIN, ${prefix}/AUTH0_AUDIENCE, and cosmos_db_endpoint are set in the store.`
    );
  }

  console.log('[appConfig] Application config fetched from Azure App Configuration');
  return { auth0Domain, auth0Audience, cosmosDbEndpoint };
}


--- File: my-homepage\frontend\auth.js ---
/* global auth0, CONFIG */

let auth0Client = null;

async function initAuth() {
  auth0Client = await auth0.createAuth0Client({
    domain: CONFIG.auth0Domain,
    clientId: CONFIG.auth0ClientId,
    authorizationParams: {
      redirect_uri: window.location.origin,
      audience: CONFIG.auth0Audience,
    },
  });

  // Handle redirect callback
  const query = window.location.search;
  if (query.includes("code=") && query.includes("state=")) {
    await auth0Client.handleRedirectCallback();
    window.history.replaceState({}, document.title, window.location.pathname);
  }

  return auth0Client;
}

async function login() {
  await auth0Client.loginWithRedirect();
}

async function logout() {
  await auth0Client.logout({
    logoutParams: { returnTo: window.location.origin },
  });
}

async function getToken() {
  return auth0Client.getTokenSilently({
    authorizationParams: { audience: CONFIG.auth0Audience },
  });
}

async function isAuthenticated() {
  return auth0Client.isAuthenticated();
}

async function getUser() {
  return auth0Client.getUser();
}


--- File: my-homepage\frontend\bookmarks.js ---
const bookmarks = [
  {
    name: "Home",
    children: [
      {
        name: "Voice",
        url: "http://voice.google.com/u/0/messages"
      },
      {
        name: "Chess",
        url: "https://www.chess.com/"
      },
      {
        name: "Reddit",
        url: "https://www.reddit.com/"
      },
      {
        name: "YouTube",
        url: "https://www.youtube.com/"
      },
      {
        name: "Google",
        url: "http://google.com/"
      },
      {
        name: "Workout",
        url: "https://docs.google.com/spreadsheets/d/1qdizKHXq5e465dt5ChbcKsGTYG6QmjON/edit?gid=1734961154#gid=1734961154"
      },
      {
        name: "Google Calendar",
        url: "https://calendar.google.com/calendar/u/0/r"
      },
      {
        name: "Amazon",
        url: "https://www.amazon.com/"
      },
      {
        name: "Nelsonhub",
        url: "http://192.168.50.131/"
      }
    ]
  },
  {
    name: "Projects",
    children: [
      {
        name: "Spacelift",
        url: "https://nelsong6.app.spacelift.io/stack/new-pokemon-appeared/run/01K4JKE4EGWVCRKAB6BZ6RXHJB"
      },
      {
        name: "Azure",
        url: "https://portal.azure.com/#home"
      },
      {
        name: "New Pokemon Appears",
        url: "https://github.com/nelsong6/new-pokemon-appeared/milestone/4"
      }
    ]
  },
  {
    name: "Bills",
    children: [
      {
        name: "Ameriprise",
        url: "https://www.ameriprise.com/client-login"
      },
      {
        name: "Chase",
        url: "https://www.chase.com/"
      },
      {
        name: "Loancare",
        url: "https://myloancare.com/web/home"
      },
      {
        name: "Water Delivery",
        url: "https://drink.water.com/"
      },
      {
        name: "Haircut",
        url: "https://www.vagaro.com/roots66salons"
      }
    ]
  },
  {
    name: "Dev",
    children: [
      {
        name: "Auth0",
        url: "http://auth0.com/"
      },
      {
        name: "Github",
        url: "https://github.com/nelsong6"
      },
      {
        name: "Spacelift",
        url: "https://nelsong6.app.us.spacelift.io/dashboard"
      },
      {
        name: "Claude",
        url: "https://platform.claude.com/"
      }
    ]
  }
];

--- File: my-homepage\frontend\bookmarks.js.example ---
const bookmarks = [
  {
    name: "Social",
    children: [
      { name: "Twitter", url: "https://twitter.com" },
      { name: "Reddit", url: "https://reddit.com" },
      { name: "YouTube", url: "https://youtube.com" },
    ],
  },
  {
    name: "Dev",
    url: "https://github.com",
    children: [
      { name: "GitHub", url: "https://github.com" },
      { name: "Stack Overflow", url: "https://stackoverflow.com" },
      { name: "MDN Web Docs", url: "https://developer.mozilla.org" },
    ],
  },
  {
    name: "News",
    children: [
      { name: "Hacker News", url: "https://news.ycombinator.com" },
      { name: "Lobsters", url: "https://lobste.rs" },
    ],
  },
  {
    name: "Tools",
    children: [
      {
        name: "Search",
        children: [
          { name: "Google", url: "https://google.com" },
          { name: "DuckDuckGo", url: "https://duckduckgo.com" },
        ],
      },
      { name: "Email", url: "https://mail.google.com" },
    ],
  },
];


--- File: my-homepage\frontend\config.js.example ---
const CONFIG = {
  auth0Domain: "<AUTH0_DOMAIN>",
  auth0ClientId: "<AUTH0_CLIENT_ID>",
  auth0Audience: "<AUTH0_AUDIENCE>",
  apiUrl: "http://localhost:3000",
};


--- File: my-homepage\frontend\generate-config.sh ---
#!/bin/bash
# Generates frontend/config.js from environment variables.
#
# Usage (local dev):
#   source backend/.env     # or export the vars manually
#   export AUTH0_DOMAIN="dev-gtdi5x5p0nmticqd.us.auth0.com"
#   export AUTH0_CLIENT_ID="<your-client-id>"
#   export AUTH0_AUDIENCE="https://homepage.api.yourdomain.com"
#   export API_URL="https://homepage.api.yourdomain.com"
#   bash frontend/generate-config.sh
#
# In the CI/CD pipeline, these variables should be set from Terraform outputs
# or Azure App Configuration before this script runs.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

: "${AUTH0_DOMAIN:?ERROR: AUTH0_DOMAIN is not set}"
: "${AUTH0_CLIENT_ID:?ERROR: AUTH0_CLIENT_ID is not set}"
: "${AUTH0_AUDIENCE:?ERROR: AUTH0_AUDIENCE is not set}"
: "${API_URL:?ERROR: API_URL is not set}"

cat <<EOF > "$SCRIPT_DIR/config.js"
const CONFIG = {
  auth0Domain: "${AUTH0_DOMAIN}",
  auth0ClientId: "${AUTH0_CLIENT_ID}",
  auth0Audience: "${AUTH0_AUDIENCE}",
  apiUrl: "${API_URL}",
};
EOF

echo "Successfully generated $SCRIPT_DIR/config.js"


--- File: my-homepage\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Login screen -->
  <div id="login-screen">
    <div class="login-box">
      <h1>Home</h1>
      <button id="login-btn">Log In</button>
    </div>
  </div>

  <!-- Loading state -->
  <div id="loading" class="hidden">Loading…</div>

  <!-- Main app (hidden until authenticated) -->
  <div id="app" class="hidden">
    <div id="toolbar">
      <button id="expand-all">Expand All</button>
      <button id="collapse-all">Collapse All</button>
      <div id="user-info">
        <span id="user-email"></span>
        <button id="logout-btn">Log Out</button>
      </div>
    </div>
    <div id="tree"></div>
  </div>

  <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
  <script src="config.js"></script>
  <script src="auth.js"></script>
  <script src="script.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js");
    }
  </script>
</body>
</html>


--- File: my-homepage\frontend\script.js ---
/* global CONFIG, initAuth, login, logout, getToken, isAuthenticated, getUser */

// ── DOM references ──────────────────────────────────────────────
const loginScreen = document.getElementById("login-screen");
const loadingEl = document.getElementById("loading");
const appEl = document.getElementById("app");
const tree = document.getElementById("tree");

const CACHE_KEY = "cached_bookmarks";

// ── App entry point ─────────────────────────────────────────────

(async function main() {
  const cached = loadCachedBookmarks();

  // If we have cached data, paint immediately — no waiting for Auth0.
  if (cached) {
    loginScreen.classList.add("hidden");
    loadingEl.classList.add("hidden");
    appEl.classList.remove("hidden");
    renderBookmarks(cached);
  } else {
    // No cache — show loading while Auth0 initializes
    loginScreen.classList.add("hidden");
    loadingEl.classList.remove("hidden");
  }

  // Auth0 init happens in the background while cached UI is already visible.
  await initAuth();

  if (await isAuthenticated()) {
    await showApp(cached);
  } else if (cached) {
    // Had stale cache but session expired — fall back to login
    showLogin();
  } else {
    showLogin();
  }
})();

// ── Auth flows ──────────────────────────────────────────────────

function showLogin() {
  loadingEl.classList.add("hidden");
  appEl.classList.add("hidden");
  loginScreen.classList.remove("hidden");
}

async function showApp(alreadyRenderedCache) {
  loadingEl.classList.add("hidden");
  loginScreen.classList.add("hidden");
  appEl.classList.remove("hidden");

  // Show user email
  const user = await getUser();
  document.getElementById("user-email").textContent = user.email || user.name || "";

  // Fetch fresh bookmarks from API (background revalidation)
  const fresh = await fetchBookmarks();

  // Only re-render if the data actually changed (or if we had no cache)
  if (!alreadyRenderedCache || !bookmarksEqual(alreadyRenderedCache, fresh)) {
    saveCachedBookmarks(fresh);
    renderBookmarks(fresh);
  }
}

// ── localStorage helpers ────────────────────────────────────────

function loadCachedBookmarks() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

function saveCachedBookmarks(bookmarks) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(bookmarks));
  } catch {
    // Storage full or unavailable — non-critical
  }
}

function bookmarksEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

// ── API ─────────────────────────────────────────────────────────

async function fetchBookmarks() {
  try {
    const token = await getToken();
    const res = await fetch(`${CONFIG.apiUrl}/api/bookmarks`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error(`API error: ${res.status}`);

    const data = await res.json();
    return data.bookmarks || [];
  } catch (err) {
    console.error("Failed to fetch bookmarks:", err);
    // On network failure, return whatever we have cached
    return loadCachedBookmarks() || [];
  }
}

// ── Rendering ───────────────────────────────────────────────────

function renderBookmarks(bookmarks) {
  tree.innerHTML = "";

  if (bookmarks.length === 0) {
    tree.textContent = "No bookmarks yet.";
    return;
  }

  tree.style.setProperty(
    "--url-left",
    Math.ceil(calcMaxRowWidth(bookmarks, "")) + 2 + "ch"
  );
  tree.appendChild(renderList(bookmarks, ""));
}

// Calculate the max visual width of all tree rows (in ch units) so
// hover-revealed URLs can be aligned in a single consistent column.
function calcMaxRowWidth(items, prefix) {
  let max = 0;
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;
    // prefix+connector chars + toggle/spacer (1ch + 0.6ch gap) + name + arrow if link
    const width = (prefix + connector).length + 1.6 + item.name.length + (item.url ? 1.15 : 0);
    if (width > max) max = width;
    if (hasChildren) {
      const childMax = calcMaxRowWidth(item.children, childPrefix);
      if (childMax > max) max = childMax;
    }
  });
  return max;
}

// Build DOM for a list of sibling nodes.
// `prefix` is the inherited string of "│   " / "    " segments from ancestors.
function renderList(items, prefix) {
  const frag = document.createDocumentFragment();
  items.forEach((item, i) => {
    const isLast = i === items.length - 1;
    const connector = isLast ? "└── " : "├── ";
    const childPrefix = prefix + (isLast ? "    " : "│   ");
    const hasChildren = Array.isArray(item.children) && item.children.length > 0;

    // Row
    const row = document.createElement("div");
    row.className = "node";

    // Prefix (inherited tree lines)
    const pre = document.createElement("span");
    pre.className = "node-prefix";
    pre.textContent = prefix + connector;
    row.appendChild(pre);

    // Toggle button or spacer
    if (hasChildren) {
      const btn = document.createElement("button");
      btn.className = "node-toggle";
      btn.textContent = ">";
      btn.setAttribute("aria-label", "expand");
      row.appendChild(btn);
    } else {
      const spacer = document.createElement("span");
      spacer.className = "node-spacer";
      row.appendChild(spacer);
    }

    // Label
    const label = document.createElement("span");
    label.className = "node-label" + (hasChildren ? " folder" : "");
    if (item.url) {
      const a = document.createElement("a");
      a.href = item.url;
      a.textContent = item.name;
      label.appendChild(a);
      const arrow = document.createElement("span");
      arrow.className = "link-indicator";
      arrow.textContent = "↗";
      arrow.setAttribute("aria-hidden", "true");
      label.appendChild(arrow);
    } else {
      label.textContent = item.name;
    }
    row.appendChild(label);

    // URL hint shown on hover
    if (item.url) {
      const urlSpan = document.createElement("span");
      urlSpan.className = "node-url";
      urlSpan.textContent = item.url;
      row.appendChild(urlSpan);
    }

    frag.appendChild(row);

    // Children
    if (hasChildren) {
      const childrenContainer = document.createElement("div");
      childrenContainer.className = "children";
      childrenContainer.appendChild(renderList(item.children, childPrefix));
      frag.appendChild(childrenContainer);

      // Wire toggle — whole row triggers expand/collapse
      const btn = row.querySelector(".node-toggle");
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        // If click landed on a link, let it navigate instead of toggling
        if (e.target.closest("a")) return;
        const open = childrenContainer.classList.toggle("open");
        btn.classList.toggle("open", open);
        btn.textContent = open ? "v" : ">";
        btn.setAttribute("aria-label", open ? "collapse" : "expand");
      });
    } else if (item.url) {
      // Wire link — whole row navigates
      row.classList.add("clickable");
      row.addEventListener("click", (e) => {
        if (e.target.tagName === "A") return; // let native <a> handle itself
        window.location.href = item.url;
      });
    }
  });
  return frag;
}

// ── Toolbar ─────────────────────────────────────────────────────

document.getElementById("expand-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.add("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.add("open");
    btn.textContent = "v";
    btn.setAttribute("aria-label", "collapse");
  });
});

document.getElementById("collapse-all").addEventListener("click", () => {
  document.querySelectorAll(".children").forEach((c) => c.classList.remove("open"));
  document.querySelectorAll(".node-toggle").forEach((btn) => {
    btn.classList.remove("open");
    btn.textContent = ">";
    btn.setAttribute("aria-label", "expand");
  });
});

document.getElementById("login-btn").addEventListener("click", login);
document.getElementById("logout-btn").addEventListener("click", logout);


--- File: my-homepage\tofu\appconfig.tf ---
# ============================================================================
# Azure App Configuration Key-Values
# ============================================================================
# These keys are read at runtime by the backend via fetchAppConfig() in
# backend/startup/appConfig.js. The Container App's managed identity has the
# "App Configuration Data Reader" role assigned in backend.tf.

resource "azurerm_app_configuration_key" "auth0_domain" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "AUTH0_DOMAIN"
  value                  = "dev-gtdi5x5p0nmticqd.us.auth0.com"
}

resource "azurerm_app_configuration_key" "auth0_audience" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "${local.front_app_dns_name}/AUTH0_AUDIENCE"
  value                  = auth0_resource_server.backend_api.identifier
}


--- File: my-homepage\tofu\backend.tf ---
# ============================================================================
# Azure Container Apps (Serverless Container Hosting)
# ============================================================================

locals {
  back_app_dns_name = "${local.front_app_dns_name}.api"
}

# Container App for the backend API
resource "azurerm_container_app" "homepage_api" {
  for_each = toset(["homepage-api"]) # Add more backend APIs here if needed
  name                         = each.key
  resource_group_name          = azurerm_resource_group.homepage.name
  container_app_environment_id = var.container_app_environment_id
  revision_mode                = "Single"

  # Enable system-assigned managed identity
  identity {
    type = "SystemAssigned"
  }

  # Container configuration
  template {
    container {
      name   = each.key
      image  = "ghcr.io/nelsong6/${terraform.workspace}/${each.key}:latest"
      cpu    = 0.25
      memory = "0.5Gi"

      env {
        name  = "PORT"
        value = "3000"
      }

      env {
        name  = "AZURE_APP_CONFIG_ENDPOINT"
        value = var.azure_app_config_endpoint
      }

      env {
        name  = "APP_CONFIG_PREFIX"
        value = local.front_app_dns_name
      }
    }

    min_replicas = 0 # Scale to zero when not in use
    max_replicas = 3
  }

  # Ingress configuration
  ingress {
    external_enabled = true
    target_port      = 3000

    traffic_weight {
      latest_revision = true
      percentage      = 100
    }

    cors {
      allowed_origins = [
        # Production: Default Azure hostname
        "https://${azurerm_static_web_app.homepage.default_host_name}",
        "https://${local.front_app_dns_name}.${var.dns_zone_name}",

        # Development: Localhost
        "http://localhost:3000",
        "http://localhost:5500"
      ]

      allowed_methods           = ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"]
      allowed_headers           = ["*"]
      exposed_headers           = ["*"]
      max_age_in_seconds        = 3600
      allow_credentials_enabled = true
    }
  }
}

# Grant Container App managed identity access to Cosmos DB
resource "azurerm_cosmosdb_sql_role_assignment" "container_app_cosmos" {
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  role_definition_id  = "${var.cosmos_db_account_id}/sqlRoleDefinitions/00000000-0000-0000-0000-000000000002" # Built-in Data Contributor
  principal_id        = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
  scope               = var.cosmos_db_account_id
}

# Grant Container App managed identity read access to Azure App Configuration
resource "azurerm_role_assignment" "container_app_appconfig_reader" {
  scope                = var.azure_app_config_resource_id
  role_definition_name = "App Configuration Data Reader"
  principal_id         = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
}

# 1. The Verification Record (Proves to Azure you own the domain)
resource "azurerm_dns_txt_record" "homepage_api_verification" {
  name                = "asuid.${local.back_app_dns_name}"
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600

  record {
    value = azurerm_container_app.homepage_api["homepage-api"].custom_domain_verification_id
  }
}

# 2. The Routing Record (Points to the container ingress)
resource "azurerm_dns_cname_record" "homepage_api" {
  name                = local.back_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_container_app.homepage_api["homepage-api"].ingress[0].fqdn
}

# 3. The Custom Domain (Unsecured initially)
resource "azurerm_container_app_custom_domain" "homepage_api" {
  name             = "${local.back_app_dns_name}.${var.dns_zone_name}"
  container_app_id = azurerm_container_app.homepage_api["homepage-api"].id

  # We must completely omit the certificate binding fields and tell Terraform
  # to ignore them, so it doesn't destroy the cert once Azure generates it.
  lifecycle {
    ignore_changes = [
      certificate_binding_type,
      container_app_environment_certificate_id
    ]
  }

  depends_on = [
    azurerm_dns_txt_record.homepage_api_verification,
    azurerm_dns_cname_record.homepage_api
  ]
}

# 4. The Auth0 Resource Server
resource "auth0_resource_server" "backend_api" {
  name        = "My Homepage Backend API"
  identifier  = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  signing_alg = "RS256"

  # Allows the frontend to request refresh tokens so users stay logged in
  allow_offline_access = true

  # Prevents the consent prompt since you own both the frontend and backend.
  skip_consent_for_verifiable_first_party_clients = true
}


--- File: my-homepage\tofu\db.tf ---
# Cosmos DB NoSQL Database (app-specific; account is managed by shared infra)
resource "azurerm_cosmosdb_sql_database" "homepage" {
  name                = "HomepageDB"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name

  lifecycle {
    ignore_changes = [throughput]
  }
}

resource "azurerm_cosmosdb_sql_container" "userdata" {
  name                = "userdata"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  database_name       = azurerm_cosmosdb_sql_database.homepage.name
  partition_key_paths = ["/userId"]

  indexing_policy {
    indexing_mode = "consistent"

    included_path {
      path = "/*"
    }
  }
}


--- File: my-homepage\tofu\frontend.tf ---
resource "azurerm_static_web_app" "homepage" {
  name                = "homepage-app"
  resource_group_name = azurerm_resource_group.homepage.name
  location            = azurerm_resource_group.homepage.location
  sku_tier            = "Free"
  sku_size            = "Free"
  lifecycle {
    ignore_changes = [
      repository_url,
      repository_branch
    ]
  }
}

locals {
  front_app_dns_name = "homepage"
}

resource "azurerm_dns_cname_record" "homepage" {
  name                = local.front_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_static_web_app.homepage.default_host_name
}

resource "azurerm_static_web_app_custom_domain" "homepage" {
  static_web_app_id = azurerm_static_web_app.homepage.id
  domain_name       = "${local.front_app_dns_name}.${var.dns_zone_name}"
  validation_type   = "cname-delegation"
  depends_on        = [azurerm_dns_cname_record.homepage]
}

resource "auth0_client" "frontend_spa" {
  name           = "My Homepage Web UI"
  app_type       = "spa"
  is_first_party = true
  callbacks = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  allowed_logout_urls = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  web_origins = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  jwt_configuration {
    alg = "RS256"
  }
  grant_types = [
    "authorization_code",
    "implicit",
    "refresh_token"
  ]
}


--- File: my-homepage\tofu\keyvault.tf ---
# ============================================================================
# Azure Key Vault (data source)
# ============================================================================
# Reads secrets from the shared Key Vault created by the bootstrap script.
# The vault name is passed via the Spacelift global context (TF_VAR_key_vault_name).

data "azurerm_key_vault" "main" {
  name                = var.key_vault_name
  resource_group_name = var.resource_group_name
}

data "azurerm_key_vault_secret" "auth0_client_secret" {
  name         = "auth0-client-secret"
  key_vault_id = data.azurerm_key_vault.main.id
}


--- File: my-homepage\tofu\main.tf ---
resource "azurerm_resource_group" "homepage" {
  name     = "homepage-rg"
  location = var.location
}

resource "terraform_data" "cd_webhook_trigger" {
  input = var.spacelift_commit_sha
}


--- File: my-homepage\tofu\outputs.tf ---
# Outputs
output "resource_group_name" {
  value       = azurerm_resource_group.homepage.name
  description = "Name of the resource group"
}

output "static_web_app_name" {
  value       = azurerm_static_web_app.homepage.name
  description = "Name of the Azure Static Web App"
}

output "static_web_app_default_hostname" {
  value       = azurerm_static_web_app.homepage.default_host_name
  description = "Default hostname of the Static Web App"
}

output "cosmos_db_name" {
  value       = var.cosmos_db_account_name
  description = "Cosmos DB account name"
}

output "cosmos_db_database_name" {
  value       = azurerm_cosmosdb_sql_database.homepage.name
  description = "Cosmos DB database name"
}

output "cosmos_db_container_name" {
  value       = azurerm_cosmosdb_sql_container.userdata.name
  description = "Cosmos DB container name for user data"
}

output "backend_api_url" {
  value       = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  description = "The URL of the backend Container App API"
}

output "container_app_name" {
  value       = azurerm_container_app.homepage_api["homepage-api"].name
  description = "Name of the backend Container App, picked up by github actions to handle custom dns for container app."
}

output "auth0_domain" {
  value       = azurerm_app_configuration_key.auth0_domain.value
  description = "Auth0 tenant domain"
}

output "auth0_client_id" {
  value       = auth0_client.frontend_spa.client_id
  description = "Auth0 SPA client ID for the frontend application"
}

output "auth0_audience" {
  value       = auth0_resource_server.backend_api.identifier
  description = "Auth0 API audience identifier for the backend"
}

output "app_config_prefix" {
  value       = local.front_app_dns_name
  description = "App Configuration key prefix, derived from the frontend DNS name"
}


--- File: my-homepage\tofu\provider.tf ---
provider "azurerm" {
  features {}
  use_oidc = true
}

provider "auth0" {
  domain        = "dev-gtdi5x5p0nmticqd.us.auth0.com"
  client_id     = "7qsN7zrBAh7TwhjEUcgtU46yOSs9TXbg"
  client_secret = data.azurerm_key_vault_secret.auth0_client_secret.value
}


--- File: my-homepage\tofu\variables.tf ---
# ============================================================================
# Application Variables
# ============================================================================

variable "location" {
  description = "Azure region where the resource group will be created"
  type        = string
  default     = "westus2"
}

variable "key_vault_name" {
  description = "Name of the shared Key Vault"
  type        = string
}

# ============================================================================
# Shared Infrastructure Variables
# ============================================================================

variable "resource_group_name" {
  description = "Name of the shared resource group"
  type        = string
}

variable "resource_group_location" {
  description = "Location of the shared resource group"
  type        = string
}

variable "resource_group_id" {
  description = "ID of the shared resource group"
  type        = string
}

variable "dns_zone_name" {
  description = "Name of the DNS zone"
  type        = string
}

variable "dns_zone_id" {
  description = "ID of the DNS zone"
  type        = string
}

variable "container_app_environment_name" {
  description = "Name of the Container App Environment"
  type        = string
}

variable "container_app_environment_id" {
  description = "ID of the Container App Environment"
  type        = string
}

variable "cosmos_db_account_name" {
  description = "Name of the Cosmos DB account"
  type        = string
}

variable "cosmos_db_account_id" {
  description = "ID of the Cosmos DB account"
  type        = string
}

variable "spacelift_commit_sha" {
  description = "The Git SHA passed dynamically from Spacelift to force an apply"
  type        = string
}

variable "azure_app_config_endpoint" {
  description = "Endpoint URL of the Azure App Configuration store (e.g. https://<store>.azconfig.io)"
  type        = string
}

variable "azure_app_config_resource_id" {
  description = "Resource ID of the Azure App Configuration store (used for RBAC role assignment)"
  type        = string
}




--- File: my-homepage\tofu\appconfig.tf ---
# ============================================================================
# Azure App Configuration Key-Values
# ============================================================================
# These keys are read at runtime by the backend via fetchAppConfig() in
# backend/startup/appConfig.js. The Container App's managed identity has the
# "App Configuration Data Reader" role assigned in backend.tf.

resource "azurerm_app_configuration_key" "auth0_domain" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "AUTH0_DOMAIN"
  value                  = "dev-gtdi5x5p0nmticqd.us.auth0.com"
}

resource "azurerm_app_configuration_key" "auth0_audience" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "${local.front_app_dns_name}/AUTH0_AUDIENCE"
  value                  = auth0_resource_server.backend_api.identifier
}

resource "azurerm_app_configuration_key" "auth0_client_id" {
  configuration_store_id = var.azure_app_config_resource_id
  key                    = "${local.front_app_dns_name}/AUTH0_CLIENT_ID"
  value                  = auth0_client.frontend_spa.client_id
}


--- File: my-homepage\tofu\backend.tf ---
# ============================================================================
# Azure Container Apps (Serverless Container Hosting)
# ============================================================================

locals {
  back_app_dns_name = "${local.front_app_dns_name}.api"
}

# Container App for the backend API
resource "azurerm_container_app" "homepage_api" {
  for_each = toset(["homepage-api"]) # Add more backend APIs here if needed
  name                         = each.key
  resource_group_name          = azurerm_resource_group.homepage.name
  container_app_environment_id = var.container_app_environment_id
  revision_mode                = "Single"

  # Enable system-assigned managed identity
  identity {
    type = "SystemAssigned"
  }

  # Container configuration
  template {
    container {
      name   = each.key
      image  = "ghcr.io/nelsong6/${terraform.workspace}/${each.key}:latest"
      cpu    = 0.25
      memory = "0.5Gi"

      env {
        name  = "PORT"
        value = "3000"
      }

      env {
        name  = "AZURE_APP_CONFIG_ENDPOINT"
        value = var.azure_app_config_endpoint
      }

      env {
        name  = "APP_CONFIG_PREFIX"
        value = local.front_app_dns_name
      }
    }

    min_replicas = 0 # Scale to zero when not in use
    max_replicas = 3
  }

  # Ingress configuration
  ingress {
    external_enabled = true
    target_port      = 3000

    traffic_weight {
      latest_revision = true
      percentage      = 100
    }

    cors {
      allowed_origins = [
        # Production: Default Azure hostname
        "https://${azurerm_static_web_app.homepage.default_host_name}",
        "https://${local.front_app_dns_name}.${var.dns_zone_name}",

        # Development: Localhost
        "http://localhost:3000",
        "http://localhost:5500"
      ]

      allowed_methods           = ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"]
      allowed_headers           = ["*"]
      exposed_headers           = ["*"]
      max_age_in_seconds        = 3600
      allow_credentials_enabled = true
    }
  }
}

# Grant Container App managed identity access to Cosmos DB
resource "azurerm_cosmosdb_sql_role_assignment" "container_app_cosmos" {
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  role_definition_id  = "${var.cosmos_db_account_id}/sqlRoleDefinitions/00000000-0000-0000-0000-000000000002" # Built-in Data Contributor
  principal_id        = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
  scope               = var.cosmos_db_account_id
}

# Grant Container App managed identity read access to Azure App Configuration
resource "azurerm_role_assignment" "container_app_appconfig_reader" {
  scope                = var.azure_app_config_resource_id
  role_definition_name = "App Configuration Data Reader"
  principal_id         = azurerm_container_app.homepage_api["homepage-api"].identity[0].principal_id
}

# 1. The Verification Record (Proves to Azure you own the domain)
resource "azurerm_dns_txt_record" "homepage_api_verification" {
  name                = "asuid.${local.back_app_dns_name}"
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600

  record {
    value = azurerm_container_app.homepage_api["homepage-api"].custom_domain_verification_id
  }
}

# 2. The Routing Record (Points to the container ingress)
resource "azurerm_dns_cname_record" "homepage_api" {
  name                = local.back_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_container_app.homepage_api["homepage-api"].ingress[0].fqdn
}

# 3. The Custom Domain (Unsecured initially)
resource "azurerm_container_app_custom_domain" "homepage_api" {
  name             = "${local.back_app_dns_name}.${var.dns_zone_name}"
  container_app_id = azurerm_container_app.homepage_api["homepage-api"].id

  # We must completely omit the certificate binding fields and tell Terraform
  # to ignore them, so it doesn't destroy the cert once Azure generates it.
  lifecycle {
    ignore_changes = [
      certificate_binding_type,
      container_app_environment_certificate_id
    ]
  }

  depends_on = [
    azurerm_dns_txt_record.homepage_api_verification,
    azurerm_dns_cname_record.homepage_api
  ]
}

# 4. The Auth0 Resource Server
resource "auth0_resource_server" "backend_api" {
  name        = "My Homepage Backend API"
  identifier  = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  signing_alg = "RS256"

  # Allows the frontend to request refresh tokens so users stay logged in
  allow_offline_access = true

  # Prevents the consent prompt since you own both the frontend and backend.
  skip_consent_for_verifiable_first_party_clients = true
}


--- File: my-homepage\tofu\db.tf ---
# Cosmos DB NoSQL Database (app-specific; account is managed by shared infra)
resource "azurerm_cosmosdb_sql_database" "homepage" {
  name                = "HomepageDB"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name

  lifecycle {
    ignore_changes = [throughput]
  }
}

resource "azurerm_cosmosdb_sql_container" "userdata" {
  name                = "userdata"
  resource_group_name = var.resource_group_name
  account_name        = var.cosmos_db_account_name
  database_name       = azurerm_cosmosdb_sql_database.homepage.name
  partition_key_paths = ["/userId"]

  indexing_policy {
    indexing_mode = "consistent"

    included_path {
      path = "/*"
    }
  }
}


--- File: my-homepage\tofu\frontend.tf ---
resource "azurerm_static_web_app" "homepage" {
  name                = "homepage-app"
  resource_group_name = azurerm_resource_group.homepage.name
  location            = azurerm_resource_group.homepage.location
  sku_tier            = "Free"
  sku_size            = "Free"
  lifecycle {
    ignore_changes = [
      repository_url,
      repository_branch
    ]
  }
}

locals {
  front_app_dns_name = "homepage"
}

resource "azurerm_dns_cname_record" "homepage" {
  name                = local.front_app_dns_name
  zone_name           = var.dns_zone_name
  resource_group_name = var.resource_group_name
  ttl                 = 3600
  record              = azurerm_static_web_app.homepage.default_host_name
}

resource "azurerm_static_web_app_custom_domain" "homepage" {
  static_web_app_id = azurerm_static_web_app.homepage.id
  domain_name       = "${local.front_app_dns_name}.${var.dns_zone_name}"
  validation_type   = "cname-delegation"
  depends_on        = [azurerm_dns_cname_record.homepage]
}

resource "auth0_client" "frontend_spa" {
  name           = "My Homepage Web UI"
  app_type       = "spa"
  is_first_party = true
  callbacks = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  allowed_logout_urls = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  web_origins = [
    "http://localhost:3000",
    "http://localhost:5500",
    "https://${local.front_app_dns_name}.${var.dns_zone_name}"
  ]
  jwt_configuration {
    alg = "RS256"
  }
  grant_types = [
    "authorization_code",
    "implicit",
    "refresh_token"
  ]
}


--- File: my-homepage\tofu\keyvault.tf ---
# ============================================================================
# Azure Key Vault (data source)
# ============================================================================
# Reads secrets from the shared Key Vault created by the bootstrap script.
# The vault name is passed via the Spacelift global context (TF_VAR_key_vault_name).

data "azurerm_key_vault" "main" {
  name                = var.key_vault_name
  resource_group_name = var.resource_group_name
}

data "azurerm_key_vault_secret" "auth0_client_secret" {
  name         = "auth0-client-secret"
  key_vault_id = data.azurerm_key_vault.main.id
}


--- File: my-homepage\tofu\main.tf ---
resource "azurerm_resource_group" "homepage" {
  name     = "homepage-rg"
  location = var.location
}

resource "terraform_data" "cd_webhook_trigger" {
  input = var.spacelift_commit_sha
}


--- File: my-homepage\tofu\outputs.tf ---
# Outputs
output "resource_group_name" {
  value       = azurerm_resource_group.homepage.name
  description = "Name of the resource group"
}

output "static_web_app_name" {
  value       = azurerm_static_web_app.homepage.name
  description = "Name of the Azure Static Web App"
}

output "static_web_app_default_hostname" {
  value       = azurerm_static_web_app.homepage.default_host_name
  description = "Default hostname of the Static Web App"
}

output "cosmos_db_name" {
  value       = var.cosmos_db_account_name
  description = "Cosmos DB account name"
}

output "cosmos_db_database_name" {
  value       = azurerm_cosmosdb_sql_database.homepage.name
  description = "Cosmos DB database name"
}

output "cosmos_db_container_name" {
  value       = azurerm_cosmosdb_sql_container.userdata.name
  description = "Cosmos DB container name for user data"
}

output "backend_api_url" {
  value       = "https://${local.back_app_dns_name}.${var.dns_zone_name}"
  description = "The URL of the backend Container App API"
}

output "container_app_name" {
  value       = azurerm_container_app.homepage_api["homepage-api"].name
  description = "Name of the backend Container App, picked up by github actions to handle custom dns for container app."
}

output "auth0_domain" {
  value       = azurerm_app_configuration_key.auth0_domain.value
  description = "Auth0 tenant domain"
}

output "auth0_client_id" {
  value       = auth0_client.frontend_spa.client_id
  description = "Auth0 SPA client ID for the frontend application"
}

output "auth0_audience" {
  value       = auth0_resource_server.backend_api.identifier
  description = "Auth0 API audience identifier for the backend"
}

output "app_config_prefix" {
  value       = local.front_app_dns_name
  description = "App Configuration key prefix, derived from the frontend DNS name"
}


--- File: my-homepage\tofu\provider.tf ---
provider "azurerm" {
  features {}
  use_oidc = true
}

provider "auth0" {
  domain        = "dev-gtdi5x5p0nmticqd.us.auth0.com"
  client_id     = "7qsN7zrBAh7TwhjEUcgtU46yOSs9TXbg"
  client_secret = data.azurerm_key_vault_secret.auth0_client_secret.value
}


--- File: my-homepage\tofu\variables.tf ---
# ============================================================================
# Application Variables
# ============================================================================

variable "location" {
  description = "Azure region where the resource group will be created"
  type        = string
  default     = "westus2"
}

variable "key_vault_name" {
  description = "Name of the shared Key Vault"
  type        = string
}

# ============================================================================
# Shared Infrastructure Variables
# ============================================================================

variable "resource_group_name" {
  description = "Name of the shared resource group"
  type        = string
}

variable "resource_group_location" {
  description = "Location of the shared resource group"
  type        = string
}

variable "resource_group_id" {
  description = "ID of the shared resource group"
  type        = string
}

variable "dns_zone_name" {
  description = "Name of the DNS zone"
  type        = string
}

variable "dns_zone_id" {
  description = "ID of the DNS zone"
  type        = string
}

variable "container_app_environment_name" {
  description = "Name of the Container App Environment"
  type        = string
}

variable "container_app_environment_id" {
  description = "ID of the Container App Environment"
  type        = string
}

variable "cosmos_db_account_name" {
  description = "Name of the Cosmos DB account"
  type        = string
}

variable "cosmos_db_account_id" {
  description = "ID of the Cosmos DB account"
  type        = string
}

variable "spacelift_commit_sha" {
  description = "The Git SHA passed dynamically from Spacelift to force an apply"
  type        = string
}

variable "azure_app_config_endpoint" {
  description = "Endpoint URL of the Azure App Configuration store (e.g. https://<store>.azconfig.io)"
  type        = string
}

variable "azure_app_config_resource_id" {
  description = "Resource ID of the Azure App Configuration store (used for RBAC role assignment)"
  type        = string
}


=============================================================
WORKSPACE FOLDER: pipeline-templates
=============================================================

--- File: pipeline-templates\README.md ---
# pipeline-templates

Pipeline templates that I don't want cluttering up my bootstrap repo.


--- File: pipeline-templates\.github\PULL_REQUEST_TEMPLATE.md ---
## Description
<!-- Provide a brief description of your changes -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Infrastructure change
- [ ] Documentation update
- [ ] Refactor

## Changes Made
<!-- List the specific changes in this PR -->

## Testing
- [ ] Tested locally
- [ ] Workflow passes
- [ ] Deployment verified

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-reviewed the code
- [ ] Updated documentation if needed
- [ ] No breaking changes (or documented if necessary)

## Related Issues
<!-- Link any related issues here -->

## Screenshots
<!-- If applicable, add screenshots to help explain your changes -->

## Deployment Notes
<!-- Any special instructions for deployment? -->


--- File: pipeline-templates\.github\workflows\container-app-build-template.yml ---
name: Container app build

on:
  workflow_call:
    inputs:
      backend_directory:
        description: 'Directory containing backend code'
        required: false
        type: string
        default: './backend'
      image_name_suffix:
        description: 'Name of the docker image (appended to repo name)'
        required: false
        type: string
        default: 'api'
      node_version:
        description: 'Node.js version for testing'
        required: false
        type: string
        default: '20'

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/${{ inputs.image_name_suffix }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: 'npm'
          cache-dependency-path: '${{ inputs.backend_directory }}/package.json'
      - run: npm ci
        working-directory: ${{ inputs.backend_directory }}
      - run: npm test || echo "Tests pass"
        working-directory: ${{ inputs.backend_directory }}

  build-backend:
    name: Build and Push Backend
    needs: test
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.backend_directory }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

--- File: pipeline-templates\.github\workflows\cspell.json ---
{
  "version": "0.2",
  "language": "en",
  "words": [
    "azurerm",
    "cspell",
    "ghcr",
    "OIDC",
    "OpenTofu",
    "passwordless",
    "tfplan",
    "tfstate",
    "tfvars",
    "Vite"
  ],
  "ignorePaths": [
    "node_modules/**",
    "dist/**"
  ]
}


--- File: pipeline-templates\.github\workflows\full-stack-deploy-template.yml ---
# .github/workflows/deploy-template.yml (in your central repo)
name: Universal Azure Deploy Template

on:
  workflow_call:
    inputs:
      target_sha:
        description: 'The commit SHA to deploy'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  REGISTRY: ghcr.io
  # github.repository will resolve to the caller's repo (e.g., nelsong6/kill-me)
  IMAGE_NAME: ${{ github.repository }}/workout-api 

jobs:
  # ============================================================================
  # JOB 1: BACKEND DEPLOYMENT
  # ============================================================================
  deploy-backend:
    name: Deploy Backend API
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for Phase 1 CI Build
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ inputs.target_sha }}
          check-name: 'build-pipeline / Build and Push Backend' 
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 15 
          allowed-conclusions: success,skipped

      - name: Install spacectl
        uses: spacelift-io/setup-spacectl@v1

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.ARM_CLIENT_ID }}
          tenant-id: ${{ vars.ARM_TENANT_ID }}
          subscription-id: ${{ vars.ARM_SUBSCRIPTION_ID }}

      - name: Fetch Spacelift Credentials from Key Vault
        run: |
          KV_ID=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-id --query value -o tsv)
          echo "::add-mask::$KV_ID"
          echo "SPACELIFT_API_KEY_ID=$KV_ID" >> $GITHUB_ENV

          KV_SECRET=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-secret --query value -o tsv)
          echo "::add-mask::$KV_SECRET"
          echo "SPACELIFT_API_KEY_SECRET=$KV_SECRET" >> $GITHUB_ENV

      - name: Fetch Backend Outputs
        env:
          SPACELIFT_API_KEY_ENDPOINT: 'https://nelsong6.app.us.spacelift.io'
        run: |
          APP_STACK_ID=${GITHUB_REPOSITORY#*/}
          
          INFRA_OUTPUTS=$(spacectl stack outputs --id infra-bootstrap --output json)
          echo "VITE_AUTH0_DOMAIN=https://$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "auth0_domain") | .value | fromjson')" >> $GITHUB_ENV
          echo "ACA_ENVIRONMENT_NAME=$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "container_app_environment_name") | .value | fromjson')" >> $GITHUB_ENV
          
          APP_OUTPUTS=$(spacectl stack outputs --id "$APP_STACK_ID" --output json)
          echo "VITE_AUTH0_CLIENT_ID=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_client_id") | .value | fromjson')" >> $GITHUB_ENV
          echo "VITE_AUTH0_AUDIENCE=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_audience") | .value | fromjson')" >> $GITHUB_ENV
          echo "CONTAINER_APP_NAME=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "container_app_name") | .value | fromjson')" >> $GITHUB_ENV
          echo "RESOURCE_GROUP_NAME=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "resource_group_name") | .value | fromjson')" >> $GITHUB_ENV
          
          RAW_URL=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "backend_api_url") | .value | fromjson')
          echo "BACKEND_HOSTNAME=${RAW_URL#https://}" >> $GITHUB_ENV

      - name: Deploy to Container App
        run: |
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.target_sha }}

      - name: Bind Custom Domain & Generate Certificate
        run: |
          az containerapp hostname bind \
            --hostname ${{ env.BACKEND_HOSTNAME }} \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --environment ${{ env.ACA_ENVIRONMENT_NAME }} \
            --validation-method CNAME

  # ============================================================================
  # JOB 2: FRONTEND DEPLOYMENT
  # ============================================================================
  deploy-frontend:
    name: Deploy React Frontend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Use the input passed from the caller
          ref: ${{ inputs.target_sha }}

      - name: Install spacectl
        uses: spacelift-io/setup-spacectl@v1

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.ARM_CLIENT_ID }}
          tenant-id: ${{ vars.ARM_TENANT_ID }}
          subscription-id: ${{ vars.ARM_SUBSCRIPTION_ID }}

      - name: Fetch Spacelift Credentials from Key Vault
        run: |
          KV_ID=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-id --query value -o tsv)
          echo "::add-mask::$KV_ID"
          echo "SPACELIFT_API_KEY_ID=$KV_ID" >> $GITHUB_ENV

          KV_SECRET=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-secret --query value -o tsv)
          echo "::add-mask::$KV_SECRET"
          echo "SPACELIFT_API_KEY_SECRET=$KV_SECRET" >> $GITHUB_ENV

      - name: Fetch Frontend Outputs
        env:
          SPACELIFT_API_KEY_ENDPOINT: 'https://nelsong6.app.us.spacelift.io'
        run: |
          APP_STACK_ID=${GITHUB_REPOSITORY#*/}
          
          INFRA_OUTPUTS=$(spacectl stack outputs --id infra-bootstrap --output json)
          echo "VITE_AUTH0_DOMAIN=https://$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "auth0_domain") | .value | fromjson')" >> $GITHUB_ENV
          
          APP_OUTPUTS=$(spacectl stack outputs --id "$APP_STACK_ID" --output json)
          echo "VITE_API_URL=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "backend_api_url") | .value | fromjson')" >> $GITHUB_ENV
          echo "VITE_AUTH0_CLIENT_ID=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_client_id") | .value | fromjson')" >> $GITHUB_ENV
          echo "VITE_AUTH0_AUDIENCE=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_audience") | .value | fromjson')" >> $GITHUB_ENV
          echo "STATIC_WEB_APP_NAME=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "static_web_app_name") | .value | fromjson')" >> $GITHUB_ENV
          echo "RESOURCE_GROUP_NAME=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "resource_group_name") | .value | fromjson')" >> $GITHUB_ENV

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: './frontend/package-lock.json'

      - name: Build Frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build

      - name: Get Static Web App Deployment Token
        id: static-web-app-token
        run: |
          TOKEN=$(az staticwebapp secrets list --name ${{ env.STATIC_WEB_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query "properties.apiKey" -o tsv)
          echo "::add-mask::$TOKEN"
          echo "deployment_token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Deploy to Azure Static Web App
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ steps.static-web-app-token.outputs.deployment_token }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "./frontend/dist"
          output_location: ""
          skip_app_build: true

--- File: pipeline-templates\.github\workflows\generate-local-env-template.yml ---
name: Generate Local .env Files

on:
  workflow_call:
    inputs:
      spacelift_endpoint:
        description: 'The Spacelift instance URL'
        required: false
        type: string
        default: 'https://nelsong6.app.us.spacelift.io'

  workflow_dispatch:
    
permissions:
  id-token: write
  contents: read

jobs:
  generate-env:
    name: Generate .env Artifact
    runs-on: ubuntu-latest

    steps:
      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.ARM_CLIENT_ID }}
          tenant-id: ${{ vars.ARM_TENANT_ID }}
          subscription-id: ${{ vars.ARM_SUBSCRIPTION_ID }}

      - name: Fetch Spacelift Credentials from Key Vault
        run: |
          set -euo pipefail

          RAW_ID=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-id --query value -o tsv)
          KV_ID=$(echo "$RAW_ID" | tr -d '\r\n')
          echo "::add-mask::$KV_ID"
          echo "SPACELIFT_API_KEY_ID=$KV_ID" >> $GITHUB_ENV

          RAW_SECRET=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-secret --query value -o tsv)
          KV_SECRET=$(echo "$RAW_SECRET" | tr -d '\r\n')
          echo "::add-mask::$KV_SECRET"
          echo "SPACELIFT_API_KEY_SECRET=$KV_SECRET" >> $GITHUB_ENV

      - name: Setup Spacelift CLI
        uses: spacelift-io/setup-spacectl@v1

      - name: Fetch Outputs & Generate Files
        env:
          SPACELIFT_API_KEY_ENDPOINT: ${{ inputs.spacelift_endpoint || 'https://nelsong6.app.us.spacelift.io' }}
        run: |
          set -euo pipefail
          APP_STACK_ID=${GITHUB_REPOSITORY#*/}

          echo "Fetching outputs from infra-bootstrap..."
          # Fetch all outputs as a JSON array
          INFRA_OUTPUTS=$(spacectl stack outputs --id infra-bootstrap --output json)
          
          # Extract specific keys and decode them to raw text
          AUTH0_DOMAIN=$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "auth0_domain") | .value | fromjson')
          APP_CONFIG_ENDPOINT=$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "azure_app_config_endpoint") | .value | fromjson')
          TENANT_ID=$(echo "$INFRA_OUTPUTS" | jq -r '.[] | select(.id == "arm_tenant_id") | .value | fromjson')

          echo "Fetching outputs from app stack: $APP_STACK_ID..."
          APP_OUTPUTS=$(spacectl stack outputs --id "$APP_STACK_ID" --output json)
          
          AUTH0_CLIENT_ID=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_client_id") | .value | fromjson')
          AUTH0_AUDIENCE=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "auth0_audience") | .value | fromjson')
          APP_PREFIX=$(echo "$APP_OUTPUTS" | jq -r '.[] | select(.id == "app_config_prefix") | .value | fromjson')

          mkdir -p env-files/frontend env-files/backend

          echo "Writing frontend/.env..."
          echo "VITE_API_URL=http://localhost:3000" > env-files/frontend/.env
          echo "VITE_AUTH0_DOMAIN=https://$AUTH0_DOMAIN" >> env-files/frontend/.env
          echo "VITE_AUTH0_CLIENT_ID=$AUTH0_CLIENT_ID" >> env-files/frontend/.env
          echo "VITE_AUTH0_AUDIENCE=$AUTH0_AUDIENCE" >> env-files/frontend/.env

          echo "Writing backend/.env..."
          echo "AZURE_APP_CONFIG_ENDPOINT=$APP_CONFIG_ENDPOINT" > env-files/backend/.env
          echo "APP_CONFIG_PREFIX=$APP_PREFIX" >> env-files/backend/.env
          echo "AZURE_TENANT_ID=$TENANT_ID" >> env-files/backend/.env

          echo "✅ Files successfully generated."

      - name: Upload .env Artifact
        uses: actions/upload-artifact@v4
        with:
          name: local-env-files
          path: env-files/
          retention-days: 1
          include-hidden-files: true

--- File: pipeline-templates\.github\workflows\lint-template.yml ---
name: Shared Repository Linting

on:
  workflow_call:
    inputs:
      working_directory:
        description: 'Directory to check'
        required: false
        type: string
        default: '.'

permissions:
  contents: read

jobs:
  # ============================================================================
  # 📝 Newline Check
  # ============================================================================
  check-newlines:
    name: Trailing Newlines
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Check for trailing newlines
        run: |
          FAILED=0
          for file in $(git grep -Il ''); do
            if [ -s "$file" ] && [ "$(tail -c 1 "$file" | wc -l)" -eq 0 ]; then
              echo "❌ Missing trailing newline: $file"
              FAILED=1
            fi
          done
          if [ $FAILED -eq 1 ]; then
            echo "Some files are missing a trailing newline. Please add an empty line to the end of the files listed above."
            exit 1
          fi

  # ============================================================================
  # 🛑 YAML Extension Check
  # ============================================================================
  check-yaml:
    name: YAML Extensions
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Enforce .yml extension
        run: |
          YAML_FILES=$(git ls-files '*.yaml')
          if [ -n "$YAML_FILES" ]; then
            echo "❌ Found files with the '.yaml' extension. Please rename them to use '.yml' instead:"
            echo "$YAML_FILES"
            exit 1
          fi

  # ============================================================================
  # 🔤 Filename Check (No Underscores)
  # ============================================================================
  check-underscores:
    name: Filename Underscores
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Enforce no underscores in filenames
        run: |
          IGNORE_LIST=$(cat << 'EOF'
          PULL_REQUEST_TEMPLATE
          ISSUE_TEMPLATE
          EOF
          )
          
          IGNORE_PATTERN=$(echo "$IGNORE_LIST" | grep -v '^$' | paste -sd '|' -)
          UNDERSCORE_FILES=$(git ls-files '*_*')
          
          if [ -z "$UNDERSCORE_FILES" ]; then
            exit 0
          fi
          
          if [ -n "$IGNORE_PATTERN" ]; then
            FAILED_FILES=$(echo "$UNDERSCORE_FILES" | grep -vE "$IGNORE_PATTERN" || true)
          else
            FAILED_FILES="$UNDERSCORE_FILES"
          fi
          
          if [ -n "$(echo "$FAILED_FILES" | grep -v '^$')" ]; then
            echo "❌ Found files with underscores in their names. Please rename them to use hyphens (-) instead:"
            echo "$FAILED_FILES"
            exit 1
          fi

  # ============================================================================
  # 📖 Spell Check
  # ============================================================================
  check-spelling:
    name: Spell Check (Markdown)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Run cspell on Markdown
        run: npx cspell "**/*.md" --no-progress

  # ============================================================================
  # 📋 Markdown Lint
  # ============================================================================
  check-markdown:
    name: Markdown Formatting
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Run Markdown Lint
        run: npx markdownlint-cli "**/*.md" --ignore "node_modules"

  # ============================================================================
  # 🏗️ OpenTofu Format
  # ============================================================================
  check-tofu:
    name: OpenTofu Format
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: 'latest'
      - name: Run tofu fmt check
        run: |
          if tofu fmt -recursive -check; then
            echo "✅ All OpenTofu files are properly formatted"
          else
            echo "❌ Format check failed. Please run 'tofu fmt -recursive' locally."
            tofu fmt -recursive -check -diff || true
            exit 1
          fi

--- File: pipeline-templates\.github\workflows\no-trailing-newspace-template.yml ---
name: Shared Repository Linting

on:
  workflow_call:
    inputs:
      working_directory:
        description: 'Directory to check'
        required: false
        type: string
        default: '.'

permissions:
  contents: read

jobs:
  no-trailing-whitespace:
    name: Trailing Whitespace
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Check for trailing whitespace
        run: |
          # Search for lines ending with a space or tab. 
          # -I ignores binary files, -n prints the line number, -E enables extended regex.
          if git grep -I -n -E '[ \t]+$'; then
            echo "::error::Trailing whitespace detected in the files listed above. Please remove it."
            exit 1
          fi
          echo "✅ No trailing whitespace found."

--- File: pipeline-templates\.github\workflows\spacelift-stack-to-main-template.yml ---
name: Shared Spacelift Branch Reset

on:
  workflow_call:
    inputs:
      spacelift_endpoint:
        description: 'The Spacelift instance URL (e.g., https://nelsong6.app.us.spacelift.io)'
        required: false
        type: string
        default: 'https://nelsong6.app.us.spacelift.io'
      target_branch:
        description: 'The branch to reset the stack to'
        required: false
        type: string
        default: 'main'

  workflow_dispatch:
    inputs:
      spacelift_endpoint:
        description: 'The Spacelift instance URL'
        required: true
        type: string
        default: 'https://nelsong6.app.us.spacelift.io'
      target_branch:
        description: 'The branch to reset the stack to'
        required: false
        type: string
        default: 'main'

permissions:
  id-token: write
  contents: read

jobs:
  reset-branch:
    name: Reset Spacelift Tracked Branch
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ vars.ARM_CLIENT_ID }}
          tenant-id: ${{ vars.ARM_TENANT_ID }}
          subscription-id: ${{ vars.ARM_SUBSCRIPTION_ID }}

      - name: Fetch Spacelift Credentials from Key Vault
        run: |
          set -euo pipefail
          
          RAW_ID=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-id --query value -o tsv)
          KV_ID=$(echo "$RAW_ID" | tr -d '\r\n')
          echo "::add-mask::$KV_ID"
          echo "SPACELIFT_API_KEY_ID=$KV_ID" >> $GITHUB_ENV

          RAW_SECRET=$(az keyvault secret show --vault-name "${{ vars.KEY_VAULT_NAME }}" --name spacelift-api-key-secret --query value -o tsv)
          KV_SECRET=$(echo "$RAW_SECRET" | tr -d '\r\n')
          echo "::add-mask::$KV_SECRET"
          echo "SPACELIFT_API_KEY_SECRET=$KV_SECRET" >> $GITHUB_ENV

      - name: Setup Spacelift CLI (spacectl)
        uses: spacelift-io/setup-spacectl@v1

      - name: Update Stack Branch
        id: update_branch
        env:
          SPACELIFT_API_KEY_ENDPOINT: ${{ inputs.spacelift_endpoint }}
          SPACELIFT_STACK_ID: ${{ github.event.repository.name }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          echo "Targeting Spacelift stack: $SPACELIFT_STACK_ID"
          
          node -e '
            const fs = require("fs");
            async function run() {
              const endpoint = process.env.SPACELIFT_API_KEY_ENDPOINT + "/graphql";
              const headers = { "Content-Type": "application/json" };
              const id = process.env.SPACELIFT_API_KEY_ID.trim();
              const secret = process.env.SPACELIFT_API_KEY_SECRET.trim();

              // 1. Authenticate via GraphQL
              const authRes = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `mutation($id: ID!, $secret: String!) { apiKeyUser(id: $id, secret: $secret) { jwt } }`,
                  variables: { id, secret }
                })
              }).then(r => r.json());
              
              if (authRes.errors) throw new Error("Auth errors: " + JSON.stringify(authRes.errors));
              headers["Authorization"] = `Bearer ${authRes.data.apiKeyUser.jwt}`;

              // 2. Fetch current stack state
              const getStack = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `query($id: ID!) { stack(id: $id) { name repository branch administrative autodeploy autoretry description projectRoot space labels workerPool { id } vendorConfig { __typename ... on StackConfigVendorTerraform { version workspace workflowTool } } } }`,
                  variables: { id: process.env.SPACELIFT_STACK_ID }
                })
              }).then(r => r.json());

              if (!getStack.data || !getStack.data.stack) throw new Error("Fetch stack failed: " + JSON.stringify(getStack));
              const stack = getStack.data.stack;
              
              // EARLY EXIT: If the branch is already correct, flag it and skip the mutation
              if (stack.branch === process.env.TARGET_BRANCH) {
                console.log(`✅ Stack "${stack.name}" is already tracking branch "${stack.branch}". Skipping update and deployment.`);
                fs.appendFileSync(process.env.GITHUB_OUTPUT, "changed=false\n");
                return;
              }

              console.log(`Resetting tracked branch from "${stack.branch}" to "${process.env.TARGET_BRANCH}" via GraphQL API...`);

              // 3. Construct StackInput perfectly mapping the existing state
              const input = {
                name: stack.name,
                repository: stack.repository,
                branch: process.env.TARGET_BRANCH,
                administrative: stack.administrative,
                autodeploy: stack.autodeploy,
                autoretry: stack.autoretry,
                description: stack.description,
                projectRoot: stack.projectRoot,
                space: stack.space,
                labels: stack.labels || [],
                workerPool: stack.workerPool ? stack.workerPool.id : null,
                vendorConfig: {}
              };

              if (stack.vendorConfig && stack.vendorConfig.__typename === "StackConfigVendorTerraform") {
                input.vendorConfig.terraform = {
                  version: stack.vendorConfig.version,
                  workspace: stack.vendorConfig.workspace,
                  workflowTool: stack.vendorConfig.workflowTool
                };
              }

              // 4. Send GraphQL Mutation
              const updateRes = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `mutation($id: ID!, $input: StackInput!) { stackUpdate(id: $id, input: $input) { id branch } }`,
                  variables: { id: process.env.SPACELIFT_STACK_ID, input }
                })
              }).then(r => r.json());

              if (updateRes.errors) throw new Error("Update failed: " + JSON.stringify(updateRes.errors));
              console.log("✅ Stack branch successfully updated to: " + updateRes.data.stackUpdate.branch);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, "changed=true\n");
            }
            run().catch(e => { console.error(e.message); process.exit(1); });
          '

      - name: Trigger Deployment
        if: steps.update_branch.outputs.changed == 'true'
        env:
          SPACELIFT_API_KEY_ENDPOINT: ${{ inputs.spacelift_endpoint }}
          SPACELIFT_STACK_ID: ${{ github.event.repository.name }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          echo "Triggering deployment on $TARGET_BRANCH..."
          spacectl stack deploy --id "$SPACELIFT_STACK_ID"
          echo "✅ Deployment triggered successfully."

--- File: pipeline-templates\.github\workflows\static-site-deploy.yml ---
name: Shared Frontend Deploy

on:
  workflow_call:
    inputs:
      frontend_directory:
        description: 'Directory containing frontend code'
        required: false
        type: string
        default: './frontend'
      spacelift_endpoint:
        description: 'Spacelift account endpoint (e.g., https://your-account.app.spacelift.io)'
        required: true
        type: string
      node_version:
        description: 'Node.js version'
        required: false
        type: string
        default: '20.x'

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node_version }}
        cache: 'npm'
        cache-dependency-path: ${{ inputs.frontend_directory }}/package-lock.json

    - name: Install dependencies
      working-directory: ${{ inputs.frontend_directory }}
      run: npm ci

    - name: Run linter
      working-directory: ${{ inputs.frontend_directory }}
      run: npm run lint || true

    - name: Run tests (when available)
      working-directory: ${{ inputs.frontend_directory }}
      run: npm test || echo "No tests configured yet"

  build-and-deploy:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate Version Tag
      id: version
      run: |
        git fetch --tags
        LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n 1)

        if [ -z "$LATEST_TAG" ]; then
          LATEST_TAG="v0.0.0"
        fi
        
        VERSION=${LATEST_TAG#v}
        IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
        
        if [[ "${{ github.event_name }}" != "pull_request" && "${{ github.ref }}" == "refs/heads/main" ]]; then
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          IS_RELEASE="true"
        else
          NEW_VERSION="${LATEST_TAG}-dev"
          IS_RELEASE="false"
        fi
        
        if git show-ref --tags --verify --quiet "refs/tags/$NEW_VERSION"; then
           NEW_PATCH=$((NEW_PATCH + 1))
           NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
        fi

        BUILD_SHA=$(git rev-parse --short HEAD)
        BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M UTC")
        
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "version_number=${NEW_VERSION#v}" >> $GITHUB_OUTPUT
        echo "build_sha=$BUILD_SHA" >> $GITHUB_OUTPUT
        echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT

    # --- SPACELIFT CLI SETUP & AUTH ---
    
    - name: Install spacectl
      uses: spacelift-io/setup-spacectl@v1

    - name: Authenticate to Spacelift via OIDC
      run: |
        spacectl profile create oidc-profile \
          --endpoint ${{ inputs.spacelift_endpoint }} \
          --type github

    - name: Fetch Global Config
      run: |
        echo "Fetching global outputs from infra-bootstrap..."
        echo "VITE_AUTH0_DOMAIN=https://$(spacectl stack output --id infra-bootstrap --name auth0_domain --raw)" >> $GITHUB_ENV
        echo "VITE_API_URL=$(spacectl stack output --id infra-bootstrap --name cosmos_db_endpoint --raw)" >> $GITHUB_ENV

    # --- DYNAMIC STACK ID RESOLUTION ---

    - name: Fetch App Config
      run: |
        APP_STACK_ID=${GITHUB_REPOSITORY#*/}
        echo "Fetching app-specific outputs for stack: $APP_STACK_ID..."
        
        echo "STATIC_WEB_APP_NAME=$(spacectl stack output --id $APP_STACK_ID --name static_web_app_name --raw)" >> $GITHUB_ENV
        echo "VITE_AUTH0_CLIENT_ID=$(spacectl stack output --id $APP_STACK_ID --name auth0_client_id --raw)" >> $GITHUB_ENV
        echo "VITE_AUTH0_AUDIENCE=$(spacectl stack output --id $APP_STACK_ID --name auth0_audience --raw)" >> $GITHUB_ENV
        echo "RESOURCE_GROUP_NAME=$(spacectl stack output --id $APP_STACK_ID --name resource_group_name --raw)" >> $GITHUB_ENV

    # --- AZURE LOGIN ---

    - name: Azure Login via OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ vars.ARM_CLIENT_ID }}
        tenant-id: ${{ vars.ARM_TENANT_ID }}
        subscription-id: ${{ vars.ARM_SUBSCRIPTION_ID }}

    # --- FRONTEND BUILD & DEPLOY ---

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node_version }}
        cache: 'npm'
        cache-dependency-path: ${{ inputs.frontend_directory }}/package-lock.json

    - name: Install dependencies
      working-directory: ${{ inputs.frontend_directory }}
      run: npm ci

    - name: Build frontend
      working-directory: ${{ inputs.frontend_directory }}
      env:
        VITE_APP_VERSION: ${{ steps.version.outputs.version_number }}
        VITE_APP_BUILD_SHA: ${{ steps.version.outputs.build_sha }}
        VITE_APP_BUILD_DATE: ${{ steps.version.outputs.build_date }}
      run: npm run build

    - name: Get Static Web App Deployment Token
      id: static-web-app-token
      run: |
        DEPLOYMENT_TOKEN=$(az staticwebapp secrets list \
          --name ${{ env.STATIC_WEB_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query "properties.apiKey" -o tsv)
        echo "::add-mask::$DEPLOYMENT_TOKEN"
        echo "deployment_token=$DEPLOYMENT_TOKEN" >> $GITHUB_OUTPUT

    - name: Deploy to Azure Static Web App
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ steps.static-web-app-token.outputs.deployment_token }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "${{ inputs.frontend_directory }}/dist"
        output_location: ""
        skip_app_build: true

    - name: Create Git Tag
      if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
      run: |
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git tag -a ${{ steps.version.outputs.version }} -m "Release ${{ steps.version.outputs.version }}"
        git push origin ${{ steps.version.outputs.version }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Get Static Web App URL
      id: swa-url
      run: |
        SWA_URL=$(az staticwebapp show \
          --name ${{ env.STATIC_WEB_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
          --query "defaultHostname" -o tsv)
        echo "url=https://$SWA_URL" >> $GITHUB_OUTPUT
        echo "### 🚀 Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "🌐 **Live at:** https://$SWA_URL" >> $GITHUB_STEP_SUMMARY

--- File: pipeline-templates\.github\workflows\tofu-deploy-template.yml ---
name: Phase 1 - CI Build

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/workout-api

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: './backend/package.json'
      - run: npm ci
        working-directory: ./backend
      - run: npm test || echo "Tests pass"
        working-directory: ./backend

  # This exact job name ("Build and Push Backend") is what Phase 3 waits for
  build-backend:
    name: Build and Push Backend
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

--- File: pipeline-templates\examples\container-app-build.yml ---
name: Phase 1 - CI Build

permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-pipeline:
    uses: nelsong6/pipeline-templates/.github/workflows/container-app-build-template.yml@main
    with:
      node_version: '20'
    secrets: inherit

--- File: pipeline-templates\examples\full-stack-deploy.yml ---
name: Phase 3 - CD Deploy

on:
  repository_dispatch:
    types: [spacelift_infra_ready]

permissions:
  id-token: write
  contents: read

jobs:
  call-deployment-template:
    uses: nelsong6/pipeline-templates/.github/workflows/full-stack-deploy-template.yml@main
    with:
      target_sha: ${{ github.event.client_payload.commit_sha }}
    secrets: inherit

--- File: pipeline-templates\examples\generate-local-env.yml ---
name: Generate Local .env Files

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  call-generate-env-template:
    uses: nelsong6/pipeline-templates/.github/workflows/generate-local-env-template.yml@main
    secrets: inherit

--- File: pipeline-templates\examples\lint.yml ---
name: Lint

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  code-quality:
    uses: nelsong6/pipeline-templates/.github/workflows/lint-template.yml@main
    with:
      working_directory: '.'

--- File: pipeline-templates\examples\spacelift-stack-to-main.yml ---
name: Reset Spacelift on PR Merge

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  reset-spacelift:
    # Run if manually triggered OR if the PR was actually merged
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    uses: nelsong6/pipeline-templates/.github/workflows/spacelift-stack-to-main-template.yml@main
    secrets: inherit

